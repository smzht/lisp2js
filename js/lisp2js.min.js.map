{"version":3,"sources":["lisp2js.js","/source/basic.lisp","/source/backquote.lisp","/source/compiler.lisp"],"names":["_possibleConstructorReturn","self","call","ReferenceError","_typeof2","_inherits","subClass","superClass","TypeError","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","_classCallCheck","instance","Constructor","Symbol","iterator","obj","_typeof","_createClass","defineProperties","target","props","i","length","descriptor","defineProperty","key","protoProps","staticProps","createLisp","installEval","installAux","g","window","GLOBAL","LISP","module","exports","document","getMyCode","currentScript","nodeList","getElementsByTagName","item","text","runCodes","codes","stream","StrStream","s","read","undefined","eval","global","arrayToList","array","result","nil","cons","jsBoolToS","x","t","makeString","inspect","inspectString","Array","map","v","join","toString","isTrue","_getRestArgs","args","start","slice","_output","process","str","stdout","write","console","log","macroTable","name","func","car","macrofn","apply","cdr","error","arguments","SObject","this","_Symbol","_SObject","_this","getPrototypeOf","symbolTable","intern","index","gensym","Keyword","_SObject2","_this2","keywordTable","type","RegExp","getTypeName","y","Cons","_SObject3","lineNo","path","_this3","abbrev","canAbbrev","ss","separator","p","push","kAbbrevTable","quote","quasiquote","unquote","unquote-splicing","list","rev","ls","d","n","toArray","substring","end","indexOf","char","charCodeAt","kEscapeCharTable","\\","\t","\n","\"","f","m","replace","print","puts","fn","_len","params","_key","last","pop","concat","JS","HashTable","_SObject4","contents","k","hasOwnProperty","hash","valueForNonExist","vector","count","rxmatch","re","exec","lastIndexOf","match","Stream","_SObject5","_this5","fetch","c","peek","regexp","keep","rightContext","readLine","_Stream","_this6","NoCloseParenException","kDelimitors","kReSingleDot","kReSymbolOrNumber","kReadUnescapeTable","readTable","Reader","eof","getc","unescape","readVector","readSymbolOrNumber","parseFloat","reversed","_1","_2","hex","String","fromCharCode","parseInt","setMacroCharacter","_c","readList","getLine","ungetc","fs","require","BUFFER_SIZE","buffer","Buffer","FileStream","_Stream2","fd","_this7","lines","closeSync","chomped","left","readSync","string","split","stdin","stderr","open","flag","openSync","e","close","load","fileSpec","fileName","exit","code","jsrequire","exp","compile","body","macroexpand","expanded","_","c2","pairs","__2","cadr","caar","cadar","pred","clauses","clause","rest","caddr","cdar","__3","expr","thn","els","loop","append","not","cddr","cdddr","xtype","__4","_loop","__5","_loop2","acc","member","assoc","acons","datum","alist","reverse","_loop3","_loop4","q","dot","dup","vect","_loop5","seq","_loop6","take","_loop7","__6","drop","__7","elt","test","_loop8","__8","__9","limit","pair","lss","types","__10","__11","tt","nreconc","tail","top","any","every","_loop9","bracket","maptree","a","__12","__13","__14","_loop10","cddar","caadar","__15","op","__16","items","__17","__18","parent$2dscope","__19","scope","val","sym","__20","it","param","traverse$2dargs","_confirm$2dvalid$2dparams","_traverse$2dquoted$2dvalue","__21","__22","new$2dscope","klass","table","__23","padding","sl","pl","__24","keyword","regex","__25","arg","__26","fnsym","pred$2dnode","then$2dnode","else$2dnode","bodies","base$2dscope","extended$2dscope","__27","rest$2dpos","proper$2dparams","__28","class$2dname","compiled$2dbody","__29","top$2dscope","tree"],"mappings":"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","file":"lisp2js.min.js","sourcesContent":["'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n(function (createLisp, installEval, installAux) {\n  'use strict';\n\n  var g = typeof window !== 'undefined' ? window : typeof GLOBAL !== 'undefined' ? GLOBAL : {};\n\n  var LISP = createLisp(g);\n  installEval(LISP);\n  installAux(LISP);\n\n  if (typeof module !== 'undefined') module.exports = LISP;else g.LISP = LISP;\n\n  // Running on browser: Execute inner text.\n  if (typeof document != 'undefined') {\n    var getMyCode = function getMyCode() {\n      var currentScript = document.currentScript || function () {\n        var nodeList = document.getElementsByTagName('script');\n        return nodeList.item(nodeList.length - 1);\n      }();\n      return currentScript.text;\n    };\n\n    // Run Lisp codes.\n    var runCodes = function runCodes(codes) {\n      var stream = new LISP.StrStream(codes);\n      for (;;) {\n        var s = LISP.read(stream);\n        if (s === undefined) break;\n        LISP.eval(s);\n      }\n    };\n\n    runCodes(getMyCode());\n  }\n})(function (global) {\n  'use strict';\n\n  var LISP = {};\n\n  // Convert JS array into Lisp list.\n  var arrayToList = function arrayToList(array) {\n    var result = LISP.nil;\n    for (var i = array.length; --i >= 0;) {\n      result = LISP.cons(array[i], result);\n    }return result;\n  };\n\n  var jsBoolToS = function jsBoolToS(x) {\n    return x ? LISP.t : LISP.nil;\n  };\n\n  var makeString = function makeString(x, inspect) {\n    if (x === LISP.nil) return 'nil';\n    if (x === LISP.t) return 't';\n    if (typeof x == 'string') return inspect ? inspectString(x) : x;\n    if (x instanceof Array) return '#(' + x.map(function (v) {\n      return makeString(v, inspect);\n    }).join(' ') + ')';\n    if (x == null) // null or undefined\n      return '' + x;\n    return x.toString(inspect);\n  };\n\n  LISP.nil = false;\n  LISP.t = true;\n\n  LISP.isTrue = function (x) {\n    return x !== LISP.nil && x != null; // !(false || null || undefined)\n  };\n\n  LISP._getRestArgs = function (args, start) {\n    return arrayToList(Array.prototype.slice.call(args, start));\n  };\n  LISP._output = typeof process !== 'undefined' ? function (str) {\n    // for node.js.\n    process.stdout.write(str);\n  } : function (str) {\n    // for browser.\n    console.log(str);\n  };\n\n  {\n    (function () {\n      var macroTable = {};\n      LISP['register-macro'] = function (name, func) {\n        macroTable[name] = func;\n        return name;\n      };\n      LISP['macroexpand-1'] = function (s) {\n        if (!LISP['pair?'](s) || !(s.car in macroTable)) return s;\n        var macrofn = macroTable[s.car];\n        return LISP.apply(macrofn, s.cdr);\n      };\n    })();\n  }\n\n  LISP.error = function () {\n    throw Array.prototype.slice.call(arguments).join(', ');\n  };\n\n  // Base class.\n\n  var SObject = function SObject() {\n    _classCallCheck(this, SObject);\n  };\n\n  // Symbol.\n\n\n  var _Symbol = function (_SObject) {\n    _inherits(_Symbol, _SObject);\n\n    function _Symbol(name) {\n      _classCallCheck(this, _Symbol);\n\n      var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(_Symbol).call(this));\n\n      _this.name = name;\n      return _this;\n    }\n\n    _createClass(_Symbol, [{\n      key: 'toString',\n      value: function toString() {\n        return this.name;\n      }\n    }], [{\n      key: 'getTypeName',\n      value: function getTypeName() {\n        return 'symbol';\n      }\n    }]);\n\n    return _Symbol;\n  }(SObject);\n\n  LISP['symbol->string'] = function (x) {\n    return x.name;\n  };\n\n  {\n    (function () {\n      var symbolTable = {}; // key(string) => Symbol object\n      LISP.intern = function (name) {\n        if (name in symbolTable) return symbolTable[name];\n        return symbolTable[name] = new _Symbol(name);\n      };\n    })();\n  }\n  {\n    (function () {\n      var index = 0;\n      LISP.gensym = function () {\n        return LISP.intern('__' + ++index);\n      };\n    })();\n  }\n\n  var Keyword = function (_SObject2) {\n    _inherits(Keyword, _SObject2);\n\n    function Keyword(name) {\n      _classCallCheck(this, Keyword);\n\n      var _this2 = _possibleConstructorReturn(this, Object.getPrototypeOf(Keyword).call(this));\n\n      _this2.name = name;\n      return _this2;\n    }\n\n    _createClass(Keyword, [{\n      key: 'toString',\n      value: function toString(inspect) {\n        return inspect ? ':' + this.name : this.name;\n      }\n    }], [{\n      key: 'getTypeName',\n      value: function getTypeName() {\n        return 'keyword';\n      }\n    }]);\n\n    return Keyword;\n  }(SObject);\n\n  {\n    (function () {\n      var keywordTable = {}; // key(string) => Keyword object\n      LISP['make-keyword'] = function (name) {\n        if (name in keywordTable) return keywordTable[name];\n        return keywordTable[name] = new Keyword(name);\n      };\n    })();\n  }\n  LISP['keyword->string'] = function (x) {\n    return x.name;\n  };\n\n  LISP.type = function (x) {\n    var type = undefined;\n    if (x === LISP.nil || x === LISP.t) type = 'bool';else {\n      type = typeof x === 'undefined' ? 'undefined' : _typeof(x);\n      if (type === 'object') {\n        if (x instanceof Array) type = 'vector';\n        if (x instanceof RegExp) type = 'regexp';else if (x instanceof SObject) type = x.constructor.getTypeName();\n      }\n    }\n    return LISP.intern(type);\n  };\n\n  LISP['eq?'] = function (x, y) {\n    return jsBoolToS(x === y);\n  };\n\n  // Cons cell.\n\n  var Cons = function (_SObject3) {\n    _inherits(Cons, _SObject3);\n\n    function Cons(car, cdr, lineNo, path) {\n      _classCallCheck(this, Cons);\n\n      var _this3 = _possibleConstructorReturn(this, Object.getPrototypeOf(Cons).call(this));\n\n      _this3.car = car;\n      _this3.cdr = cdr;\n\n      if (lineNo != null) {\n        _this3.lineNo = lineNo;\n        _this3.path = path;\n      }\n      return _this3;\n    }\n\n    _createClass(Cons, [{\n      key: 'toString',\n      value: function toString(inspect) {\n        var abbrev = Cons.canAbbrev(this);\n        if (abbrev) return '' + abbrev + makeString(this.cdr.car, inspect);\n\n        var ss = [];\n        var separator = '(';\n        var p = undefined;\n        for (p = this; p instanceof Cons; p = p.cdr) {\n          ss.push(separator);\n          ss.push(makeString(p.car, inspect));\n          separator = ' ';\n        }\n        if (p !== LISP.nil) {\n          ss.push(' . ');\n          ss.push(makeString(p, inspect));\n        }\n        ss.push(')');\n        return ss.join('');\n      }\n    }, {\n      key: 'toArray',\n      value: function toArray() {\n        var result = [];\n        for (var p = this; p instanceof Cons; p = p.cdr) {\n          result.push(p.car);\n        }return result;\n      }\n    }], [{\n      key: 'getTypeName',\n      value: function getTypeName() {\n        return 'pair';\n      }\n    }, {\n      key: 'canAbbrev',\n      value: function canAbbrev(s) {\n        var kAbbrevTable = {\n          quote: '\\'',\n          quasiquote: '`',\n          unquote: ',',\n          'unquote-splicing': ',@'\n        };\n        return s.car instanceof _Symbol && s.car.name in kAbbrevTable && s.cdr instanceof Cons && LISP['eq?'](s.cdr.cdr, LISP.nil) ? kAbbrevTable[s.car.name] : false;\n      }\n    }]);\n\n    return Cons;\n  }(SObject);\n\n  LISP.cons = function (car, cdr) {\n    return new Cons(car, cdr);\n  };\n  LISP.car = function (s) {\n    if (s instanceof Cons) return s.car;\n    return s;\n  };\n  LISP.cdr = function (s) {\n    if (s instanceof Cons) return s.cdr;\n    return LISP.nil;\n  };\n  LISP['set-car!'] = function (s, x) {\n    return s.car = x;\n  };\n  LISP['set-cdr!'] = function (s, x) {\n    return s.cdr = x;\n  };\n\n  LISP.list = function () {\n    var result = LISP.nil;\n    for (var i = arguments.length; --i >= 0;) {\n      result = LISP.cons(arguments[i], result);\n    }return result;\n  };\n  LISP['reverse!'] = function (x) {\n    var rev = LISP.nil;\n    for (var ls = x; LISP['pair?'](ls);) {\n      var d = ls.cdr;\n      ls.cdr = rev;\n      rev = ls;\n      ls = d;\n    }\n    return rev;\n  };\n\n  LISP['number->string'] = function (x, n) {\n    return x.toString(n);\n  };\n  LISP['+'] = function () {\n    if (arguments.length == 0) return 0;\n    var result = arguments[0];\n    for (var i = 1; i < arguments.length; ++i) {\n      result += arguments[i];\n    }return result;\n  };\n  LISP['*'] = function () {\n    if (arguments.length == 0) return 1;\n    var result = arguments[0];\n    for (var i = 1; i < arguments.length; ++i) {\n      result *= arguments[i];\n    }return result;\n  };\n  LISP['-'] = function () {\n    if (arguments.length == 0) return 0;\n    var result = arguments[0];\n    if (arguments.length == 1) return -result;\n    for (var i = 1; i < arguments.length; ++i) {\n      result -= arguments[i];\n    }return result;\n  };\n  LISP['/'] = function () {\n    if (arguments.length == 0) return 1;\n    var result = arguments[0];\n    if (arguments.length == 1) return 1.0 / result;\n    for (var i = 1; i < arguments.length; ++i) {\n      result /= arguments[i];\n    }return result;\n  };\n  LISP['%'] = function () {\n    if (arguments.length == 0) return 0;\n    var result = arguments[0];\n    if (arguments.length == 1) return result;\n    for (var i = 1; i < arguments.length; ++i) {\n      result %= arguments[i];\n    }return result;\n  };\n  LISP['<'] = function () {\n    if (arguments.length > 0) {\n      var value = arguments[0];\n      for (var i = 1; i < arguments.length; ++i) {\n        var target = arguments[i];\n        if (!(value < target)) return LISP.nil;\n        value = target;\n      }\n    }\n    return LISP.t;\n  };\n  LISP['>'] = function () {\n    if (arguments.length > 0) {\n      var value = arguments[0];\n      for (var i = 1; i < arguments.length; ++i) {\n        var target = arguments[i];\n        if (!(value > target)) return LISP.nil;\n        value = target;\n      }\n    }\n    return LISP.t;\n  };\n  LISP['<='] = function () {\n    if (arguments.length > 0) {\n      var value = arguments[0];\n      for (var i = 1; i < arguments.length; ++i) {\n        var target = arguments[i];\n        if (!(value <= target)) return LISP.nil;\n        value = target;\n      }\n    }\n    return LISP.t;\n  };\n  LISP['>='] = function () {\n    if (arguments.length > 0) {\n      var value = arguments[0];\n      for (var i = 1; i < arguments.length; ++i) {\n        var target = arguments[i];\n        if (!(value >= target)) return LISP.nil;\n        value = target;\n      }\n    }\n    return LISP.t;\n  };\n\n  // String.\n  LISP['string=?'] = function (x, y) {\n    return jsBoolToS(x === y);\n  };\n  LISP['string-append'] = function () {\n    return Array.prototype.slice.call(arguments).join('');\n  };\n  LISP['string-join'] = function (list, separator) {\n    if (list === LISP.nil) return '';\n    return list.toArray().join(separator);\n  };\n  LISP['string-length'] = function (str) {\n    return str.length;\n  };\n  LISP['string-ref'] = function (str, index) {\n    return str[index];\n  };\n  LISP.substring = function (str, start, end) {\n    return str.slice(start, end);\n  };\n  LISP['string-scan'] = function (str, item) {\n    var index = str.indexOf(item);\n    return index >= 0 ? index : LISP.nil;\n  };\n\n  LISP['char->integer'] = function (char, index) {\n    return char.charCodeAt(index);\n  };\n\n  var kEscapeCharTable = { '\\\\': '\\\\\\\\', '\\t': '\\\\t', '\\n': '\\\\n', '\"': '\\\\\"' };\n  var inspectString = function inspectString(str) {\n    var f = function f(m) {\n      if (m in kEscapeCharTable) return kEscapeCharTable[m];\n      return '\\\\x' + ('0' + m.charCodeAt(0).toString(16)).slice(-2);\n    };\n    return '\"' + str.replace(/[\\x00-\\x1f\\\"\\\\]/g, f) + '\"';\n  };\n\n  LISP['x->string'] = makeString;\n  LISP.print = function (x, stream) {\n    var s = makeString(x);\n    if (stream) stream.write(s);else LISP._output(s);\n    return x;\n  };\n  LISP.puts = function (x) {\n    LISP._output(makeString(x));\n    if (typeof process !== 'undefined') LISP._output('\\n');\n    return x;\n  };\n  LISP.write = function (x) {\n    LISP._output(makeString(x, 10)); // 10 means true, and it is used as radix.\n    return x;\n  };\n\n  LISP.apply = function (fn) {\n    for (var _len = arguments.length, params = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      params[_key - 1] = arguments[_key];\n    }\n\n    if (params.length > 0) {\n      // Last argument for `apply` is expected as list (or nil).\n      var last = params.pop();\n      if (last !== LISP.nil) params = params.concat(last.toArray());\n    }\n    return fn.apply(null, params);\n  };\n  LISP.JS = global;\n\n  var HashTable = function (_SObject4) {\n    _inherits(HashTable, _SObject4);\n\n    function HashTable() {\n      _classCallCheck(this, HashTable);\n\n      return _possibleConstructorReturn(this, Object.getPrototypeOf(HashTable).apply(this, arguments));\n    }\n\n    _createClass(HashTable, [{\n      key: 'toString',\n      value: function toString() {\n        var contents = '';\n        for (var k in this) {\n          if (!this.hasOwnProperty(k)) continue;\n          if (contents.length > 0) contents += ', ';\n          contents += k + ':' + this[k];\n        }\n        return '#table<' + contents + '>';\n      }\n    }], [{\n      key: 'getTypeName',\n      value: function getTypeName() {\n        return 'table';\n      }\n    }]);\n\n    return HashTable;\n  }(SObject);\n\n  LISP.HashTable = HashTable;\n\n  // Hash table.\n  LISP['make-hash-table'] = function () {\n    return new HashTable();\n  };\n  LISP['hash-table-exists?'] = function (hash, x) {\n    return x in hash ? LISP.t : LISP.nil;\n  };\n  LISP['hash-table-get'] = function (hash, x) {\n    var valueForNonExist = arguments.length <= 2 || arguments[2] === undefined ? LISP.nil : arguments[2];\n\n    return x in hash ? hash[x] : valueForNonExist;\n  };\n  LISP['hash-table-put!'] = function (hash, x, value) {\n    return hash[x] = value;\n  };\n\n  // Vector.\n  LISP.vector = function () {\n    return Array.prototype.slice.call(arguments);\n  };\n  LISP['make-vector'] = function (count, value) {\n    if (value === undefined) value = LISP.nil;\n    var vector = new Array(count);\n    for (var i = 0; i < count; ++i) {\n      vector[i] = value;\n    }return vector;\n  };\n  LISP['vector-length'] = function (vector) {\n    return vector.length;\n  };\n  LISP['vector-ref'] = function (vector, index) {\n    return vector[index];\n  };\n  LISP['vector-set!'] = function (vector, index, value) {\n    return vector[index] = value;\n  };\n\n  // Regexp.\n  LISP.rxmatch = function (re, str) {\n    return jsBoolToS(re.exec(str));\n  };\n  LISP['regexp-replace-all'] = function (re, str, fn) {\n    if (!re.global) {\n      var s = re.toString();\n      var i = s.lastIndexOf('/');\n      re = new RegExp(s.slice(1, i), s.slice(i + 1) + 'g');\n    }\n    return str.replace(re, function (match) {\n      return fn(function () {\n        // TODO: handle arguments.\n        return match;\n      });\n    });\n  };\n  LISP['regexp->string'] = function (x) {\n    var s = x.toString();\n    return s.slice(1, s.length - 1);\n  };\n\n  // Stream.\n\n  var Stream = function (_SObject5) {\n    _inherits(Stream, _SObject5);\n\n    function Stream() {\n      _classCallCheck(this, Stream);\n\n      var _this5 = _possibleConstructorReturn(this, Object.getPrototypeOf(Stream).call(this));\n\n      _this5.str = '';\n      _this5.lineNo = 0;\n      return _this5;\n    }\n\n    _createClass(Stream, [{\n      key: 'close',\n      value: function close() {}\n    }, {\n      key: 'peek',\n      value: function peek() {\n        var result = this.fetch();\n        if (result == null) return result;\n        return this.str[0];\n      }\n    }, {\n      key: 'getc',\n      value: function getc() {\n        var c = this.peek();\n        if (c == null) return c;\n        this.str = this.str.slice(1);\n        return c;\n      }\n    }, {\n      key: 'ungetc',\n      value: function ungetc(c) {\n        if (this.str) this.str = c + this.str;else this.str = c;\n      }\n    }, {\n      key: 'match',\n      value: function match(regexp, keep) {\n        var result = this.fetch();\n        if (result == null) return result;\n\n        var m = this.str.match(regexp);\n        if (m && !keep) this.str = RegExp.rightContext;\n        return m;\n      }\n    }, {\n      key: 'eof',\n      value: function eof() {\n        return this.str == null;\n      }\n    }, {\n      key: 'getLine',\n      value: function getLine() {\n        var result = this.str || this.readLine();\n        this.str = '';\n        return result;\n      }\n    }, {\n      key: 'fetch',\n      value: function fetch() {\n        if (this.str == null) return null;\n\n        if (this.str === '') {\n          if ((this.str = this.readLine()) == null) return undefined;\n          ++this.lineNo;\n        }\n        return this.str;\n      }\n    }]);\n\n    return Stream;\n  }(SObject);\n\n  var StrStream = function (_Stream) {\n    _inherits(StrStream, _Stream);\n\n    function StrStream(str) {\n      _classCallCheck(this, StrStream);\n\n      var _this6 = _possibleConstructorReturn(this, Object.getPrototypeOf(StrStream).call(this));\n\n      _this6.str = str;\n      _this6.lineNo = 1;\n      return _this6;\n    }\n\n    _createClass(StrStream, [{\n      key: 'readLine',\n      value: function readLine() {\n        return null;\n      }\n    }]);\n\n    return StrStream;\n  }(Stream);\n\n  LISP.StrStream = StrStream;\n\n  // Reader.\n  LISP.NoCloseParenException = function () {};\n\n  var kDelimitors = '\\\\s(){}\\\\[\\\\]\\'`,;#\"';\n  var kReSingleDot = RegExp('^\\\\.(?=[' + kDelimitors + '])');\n  var kReSymbolOrNumber = RegExp('^([^' + kDelimitors + ']+)');\n  var kReadUnescapeTable = {\n    't': '\\t',\n    'n': '\\n'\n  };\n\n  var readTable = {};\n\n  var Reader = function () {\n    function Reader() {\n      _classCallCheck(this, Reader);\n    }\n\n    _createClass(Reader, null, [{\n      key: 'read',\n      value: function read(stream) {\n        do {\n          if (stream.eof()) return null;\n        } while (stream.match(/^(\\s+|$)/));\n\n        var c = stream.peek();\n        if (c in readTable) return readTable[c](stream, stream.getc());\n\n        var m = undefined;\n        if (stream.match(/^;[^\\n]*\\n?/)) // Line comment.\n          return Reader.read(stream);\n        if (m = stream.match(/^\"((\\\\.|[^\"\\\\])*)\"/)) // string.\n          return Reader.unescape(m[1]);\n        if (stream.match(/^#\\(/)) // vector.\n          return Reader.readVector(stream);\n        if (m = stream.match(/^#\\/([^\\/]*)\\//)) // regexp\n          return new RegExp(m[1]); // TODO: Implement properly.\n        if (stream.match(/^#\\|(.|[\\n\\r])*?\\|#/)) // Block comment.\n          return Reader.read(stream);\n        if (stream.match(kReSingleDot, true)) // Single dot.\n          return undefined;\n        if (m = stream.match(kReSymbolOrNumber)) // Symbol or number.\n          return Reader.readSymbolOrNumber(m[1]);\n        return undefined;\n      }\n    }, {\n      key: 'readSymbolOrNumber',\n      value: function readSymbolOrNumber(str) {\n        if (str === 'nil') return LISP.nil;\n        if (str === 't') return LISP.t;\n        if (str[0] === ':') return LISP['make-keyword'](str.slice(1));\n        if (str.match(/^([+\\-]?[0-9]+(\\.[0-9]*)?)$/)) // Number.\n          return parseFloat(str);\n        return LISP.intern(str);\n      }\n    }, {\n      key: 'readList',\n      value: function readList(stream) {\n        var result = LISP.nil;\n        for (;;) {\n          var x = Reader.read(stream);\n          if (x == null) break;\n          result = new Cons(x, result, stream.lineNo, stream.path);\n        }\n\n        if (stream.match(/^\\s*\\)/)) // Close paren.\n          return LISP['reverse!'](result);\n        if (stream.match(kReSingleDot)) {\n          // Dot.\n          var last = Reader.read(stream);\n          if (last != null) {\n            if (stream.match(/^\\s*\\)/)) {\n              // Close paren.\n              var reversed = LISP['reverse!'](result);\n              result.cdr = last;\n              return reversed;\n            }\n          }\n        }\n        // Error\n        throw new LISP.NoCloseParenException();\n      }\n    }, {\n      key: 'readVector',\n      value: function readVector(stream) {\n        var result = [];\n        for (;;) {\n          var x = Reader.read(stream);\n          if (x == null) break;\n          result.push(x);\n        }\n\n        if (stream.match(/^\\s*\\)/)) // Close paren.\n          return result;\n        // Error\n        throw new LISP.NoCloseParenException();\n      }\n    }, {\n      key: 'unescape',\n      value: function unescape(str) {\n        return str.replace(/\\\\(x([0-9a-fA-F]{2})|(.))/g, function (_1, _2, hex, c) {\n          if (hex) return String.fromCharCode(parseInt(hex, 16));\n          if (c in kReadUnescapeTable) return kReadUnescapeTable[c];\n          return c;\n        });\n      }\n    }, {\n      key: 'setMacroCharacter',\n      value: function setMacroCharacter(c, fn) {\n        readTable[c] = fn;\n      }\n    }]);\n\n    return Reader;\n  }();\n\n  LISP['set-macro-character'] = Reader.setMacroCharacter;\n\n  Reader.setMacroCharacter('(', function (stream, _c) {\n    return (// Left paren '('.\n      Reader.readList(stream)\n    );\n  });\n\n  LISP.read = function (stream) {\n    return Reader.read(stream || LISP['*stdin*']);\n  };\n\n  LISP['read-from-string'] = function (str) {\n    return Reader.read(new StrStream(str));\n  };\n\n  LISP['read-line'] = function (stream) {\n    return (stream || LISP['*stdin*']).getLine();\n  };\n\n  LISP['read-char'] = function () {\n    var stream = arguments.length <= 0 || arguments[0] === undefined ? LISP['*stdin*'] : arguments[0];\n\n    return stream.getc();\n  };\n\n  LISP['unread-char'] = function (c) {\n    var stream = arguments.length <= 1 || arguments[1] === undefined ? LISP['*stdin*'] : arguments[1];\n\n    stream.ungetc(c);\n    return LISP.nil;\n  };\n\n  // For node JS.\n  if (typeof process !== 'undefined') {\n    (function () {\n      var fs = require('fs');\n\n      var BUFFER_SIZE = 4096;\n      var buffer = new Buffer(BUFFER_SIZE);\n\n      var FileStream = function (_Stream2) {\n        _inherits(FileStream, _Stream2);\n\n        function FileStream(fd, path) {\n          _classCallCheck(this, FileStream);\n\n          var _this7 = _possibleConstructorReturn(this, Object.getPrototypeOf(FileStream).call(this));\n\n          _this7.fd = fd;\n          _this7.path = path;\n          _this7.lines = [];\n          _this7.index = 0;\n          return _this7;\n        }\n\n        _createClass(FileStream, [{\n          key: 'close',\n          value: function close() {\n            if (this.fd == null) return;\n            fs.closeSync(this.fd);\n            this.fd = null;\n            this.lines.length = this.index = 0;\n            this.str = null;\n            this.chomped = false;\n          }\n        }, {\n          key: 'readLine',\n          value: function readLine() {\n            for (;;) {\n              var left = '';\n              if (this.index < this.lines.length) {\n                if (this.index < this.lines.length - 1 || !this.chomped) return this.lines[this.index++];\n                if (this.chomped) left = this.lines[this.index];\n              }\n\n              if (this.fd == null) return LISP.nil;\n              var n = fs.readSync(this.fd, buffer, 0, BUFFER_SIZE);\n              if (n <= 0) return null;\n              var string = left + buffer.slice(0, n).toString();\n              this.chomped = false;\n              if (string.length > 0) {\n                if (string[string.length - 1] != '\\n') this.chomped = true;else\n                  // Remove last '\\n' to avoid last empty line.\n                  string = string.slice(0, string.length - 1);\n              }\n              this.lines = string.split('\\n');\n              this.index = 0;\n            }\n          }\n        }, {\n          key: 'write',\n          value: function write(s) {\n            fs.write(this.fd, s);\n          }\n        }]);\n\n        return FileStream;\n      }(Stream);\n\n      LISP.FileStream = FileStream;\n\n      LISP['*stdin*'] = new FileStream(process.stdin.fd, '*stdin*');\n      LISP['*stdout*'] = new FileStream(process.stdout.fd, '*stdout*');\n      LISP['*stderr*'] = new FileStream(process.stderr.fd, '*stderr*');\n\n      LISP.open = function (path, flag) {\n        try {\n          var fd = fs.openSync(path, flag || 'r');\n          return new LISP.FileStream(fd, path);\n        } catch (e) {\n          return LISP.nil;\n        }\n      };\n\n      LISP.close = function (stream) {\n        stream.close();\n        return stream;\n      };\n\n      LISP.load = function (fileSpec) {\n        var stream = undefined;\n        if (typeof fileSpec == 'string') {\n          stream = LISP.open(fileSpec);\n          if (!stream) return LISP.error('Cannot open [' + fileName + ']');\n        } else if (fileSpec instanceof Stream) stream = fileSpec;else return LISP.error('Illegal fileSpec: ' + fileSpec);\n\n        if (stream.match(/^#!/, true)) stream.getLine(); // Skip Shebang.\n\n        var result = undefined;\n        for (;;) {\n          var s = LISP.read(stream);\n          if (s == null) break;\n          result = LISP.eval(s);\n        }\n        if (stream !== fileSpec) LISP.close(stream);\n        return result;\n      };\n\n      // System\n      LISP.exit = function (code) {\n        return process.exit(code);\n      };\n\n      LISP.jsrequire = require;\n    })();\n  }\n\n  return LISP;\n}, function (LISP) {\n  // Using eval JS function prevent uglify to mangle local variable names,\n  // so put such code here.\n  LISP.eval = function (exp) {\n    return eval(LISP.compile(exp));\n  };\n}, function ( /*eslint no-unused-vars: 0*/LISP) {\n  /*==== EMBED COMPILED CODE HERE ====*/\n  LISP[\"register-macro\"](LISP.intern(\"defmacro\"), function (name, params) {\n    var body = LISP._getRestArgs(arguments, 2);return LISP.list(LISP.intern(\"register-macro\"), LISP.list(LISP.intern(\"quote\"), name), LISP[\"list*\"](LISP.intern(\"lambda\"), params, body));\n  });\n  LISP.macroexpand = function (exp) {\n    return function (expanded) {\n      return LISP.isTrue(LISP[\"equal?\"](expanded, exp)) ? exp : LISP.macroexpand(expanded);\n    }(LISP[\"macroexpand-1\"](exp));\n  };\n  LISP[\"set-macro-character\"](\"'\", function (stream, _) {\n    return LISP.list(LISP.intern(\"quote\"), LISP.read(stream));\n  });\n  LISP[\"set-macro-character\"](\"`\", function (stream, _) {\n    return LISP.list(LISP.intern(\"quasiquote\"), LISP.read(stream));\n  });\n  LISP[\"set-macro-character\"](\",\", function (stream, _) {\n    return function (c2) {\n      return LISP.isTrue(LISP[\"eq?\"](c2, \"@\")) ? LISP.list(LISP.intern(\"unquote-splicing\"), LISP.read(stream)) : function () {\n        return LISP[\"unread-char\"](c2, stream), LISP.list(LISP.intern(\"unquote\"), LISP.read(stream));\n      }();\n    }(LISP[\"read-char\"](stream));\n  });\n  LISP[\"register-macro\"](LISP.intern(\"defun\"), function (name, params) {\n    var body = LISP._getRestArgs(arguments, 2);return LISP.list(LISP.intern(\"def\"), name, LISP[\"list*\"](LISP.intern(\"lambda\"), params, body));\n  });\n  LISP[\"register-macro\"](LISP.intern(\"let\"), function (pairs) {\n    var body = LISP._getRestArgs(arguments, 1);return LISP.isTrue(LISP[\"symbol?\"](pairs)) ? function () {\n      var __2 = LISP.list(LISP.nil);return function (name, pairs, body) {\n        return LISP[\"list*\"](LISP.list(LISP.intern(\"lambda\"), LISP.list(name), LISP.list(LISP.intern(\"set!\"), name, LISP[\"list*\"](LISP.intern(\"lambda\"), LISP.map(LISP.car, pairs), body)), LISP[\"list*\"](name, LISP.map(LISP.cadr, pairs))), __2);\n      };\n    }()(pairs, LISP.car(body), LISP.cdr(body)) : LISP[\"list*\"](LISP[\"list*\"](LISP.intern(\"lambda\"), LISP.map(LISP.car, pairs), body), LISP.map(LISP.cadr, pairs));\n  });\n  LISP[\"register-macro\"](LISP.intern(\"let1\"), function (name, value) {\n    var body = LISP._getRestArgs(arguments, 2);return LISP[\"list*\"](LISP.intern(\"let\"), LISP.list(LISP.list(name, value)), body);\n  });\n  LISP[\"register-macro\"](LISP.intern(\"let*\"), function (pairs) {\n    var body = LISP._getRestArgs(arguments, 1);return LISP.isTrue(LISP[\"null?\"](pairs)) ? LISP[\"list*\"](LISP.intern(\"progn\"), body) : LISP.list(LISP.intern(\"let1\"), LISP.caar(pairs), LISP.cadar(pairs), LISP[\"list*\"](LISP.intern(\"let*\"), LISP.cdr(pairs), body));\n  });\n  LISP[\"register-macro\"](LISP.intern(\"when\"), function (pred) {\n    var body = LISP._getRestArgs(arguments, 1);return LISP.list(LISP.intern(\"if\"), pred, LISP[\"list*\"](LISP.intern(\"progn\"), body));\n  });\n  LISP[\"register-macro\"](LISP.intern(\"unless\"), function (pred) {\n    var body = LISP._getRestArgs(arguments, 1);return LISP.list(LISP.intern(\"if\"), pred, LISP.nil, LISP[\"list*\"](LISP.intern(\"progn\"), body));\n  });\n  LISP[\"register-macro\"](LISP.intern(\"cond\"), function () {\n    var clauses = LISP._getRestArgs(arguments, 0);return LISP.isTrue(LISP[\"null?\"](clauses)) ? LISP.nil : function (clause, rest) {\n      return LISP.isTrue(LISP[\"eq?\"](LISP.car(clause), LISP.t)) ? LISP[\"list*\"](LISP.intern(\"progn\"), LISP.cdr(clause)) : LISP.isTrue(LISP[\"null?\"](LISP.cdr(clause))) ? function (g) {\n        return LISP.list(LISP.intern(\"let\"), LISP.list(LISP.list(g, LISP.car(clause))), LISP.list(LISP.intern(\"if\"), g, g, LISP[\"list*\"](LISP.intern(\"cond\"), rest)));\n      }(LISP.gensym()) : LISP.isTrue(LISP[\"eq?\"](LISP.cadr(clause), LISP.intern(\"=>\"))) ? function (g) {\n        return LISP.list(LISP.intern(\"let\"), LISP.list(LISP.list(g, LISP.car(clause))), LISP.list(LISP.intern(\"if\"), g, LISP.list(LISP.caddr(clause), g), LISP[\"list*\"](LISP.intern(\"cond\"), rest)));\n      }(LISP.gensym()) : LISP.list(LISP.intern(\"if\"), LISP.car(clause), LISP[\"list*\"](LISP.intern(\"progn\"), LISP.cdr(clause)), LISP[\"list*\"](LISP.intern(\"cond\"), rest));\n    }(LISP.car(clauses), LISP.cdr(clauses));\n  });\n  LISP[\"register-macro\"](LISP.intern(\"case\"), function (x) {\n    var clauses = LISP._getRestArgs(arguments, 1);return function (value) {\n      return LISP.list(LISP.intern(\"let1\"), value, x, LISP[\"list*\"](LISP.intern(\"cond\"), LISP.map(function (clause) {\n        return LISP.isTrue(LISP[\"eq?\"](LISP.car(clause), LISP.t)) ? clause : LISP.isTrue(LISP[\"null?\"](LISP.cdar(clause))) ? LISP[\"list*\"](LISP.list(LISP.intern(\"eq?\"), value, LISP.list(LISP.intern(\"quote\"), LISP.caar(clause))), LISP.cdr(clause)) : LISP[\"list*\"](LISP.list(LISP.intern(\"member\"), value, LISP.list(LISP.intern(\"quote\"), LISP.car(clause))), LISP.cdr(clause));\n      }, clauses)));\n    }(LISP.gensym());\n  });\n  LISP[\"register-macro\"](LISP.intern(\"and\"), function () {\n    var __3 = LISP.list(LISP.nil);return function () {\n      var args = LISP._getRestArgs(arguments, 0);return LISP.isTrue(LISP[\"null?\"](args)) ? LISP.t : LISP.isTrue(LISP[\"null?\"](LISP.cdr(args))) ? LISP.car(args) : LISP[\"list*\"](LISP.intern(\"if\"), LISP.car(args), LISP[\"list*\"](LISP.intern(\"and\"), LISP.cdr(args)), __3);\n    };\n  }());\n  LISP[\"register-macro\"](LISP.intern(\"or\"), function () {\n    var args = LISP._getRestArgs(arguments, 0);return LISP.isTrue(LISP[\"null?\"](LISP.cdr(args))) ? LISP.car(args) : function (g) {\n      return LISP.list(LISP.intern(\"let1\"), g, LISP.car(args), LISP.list(LISP.intern(\"if\"), g, g, LISP[\"list*\"](LISP.intern(\"or\"), LISP.cdr(args))));\n    }(LISP.gensym());\n  });\n  LISP[\"register-macro\"](LISP.intern(\"progn\"), function () {\n    var body = LISP._getRestArgs(arguments, 0);return LISP.isTrue(LISP[\"null?\"](body)) ? LISP.nil : LISP.isTrue(LISP[\"null?\"](LISP.cdr(body))) ? LISP.car(body) : LISP[\"list*\"](LISP.intern(\"let\"), LISP.nil, body);\n  });\n  LISP[\"register-macro\"](LISP.intern(\"aif\"), function (expr, thn) {\n    var els = LISP._getRestArgs(arguments, 2);return LISP.list(LISP.intern(\"let1\"), LISP.intern(\"it\"), expr, LISP[\"list*\"](LISP.intern(\"if\"), LISP.intern(\"it\"), thn, els));\n  });\n  LISP[\"register-macro\"](LISP.intern(\"awhen\"), function (expr) {\n    var body = LISP._getRestArgs(arguments, 1);return LISP.list(LISP.intern(\"aif\"), expr, LISP[\"list*\"](LISP.intern(\"progn\"), body));\n  });\n  LISP[\"register-macro\"](LISP.intern(\"awhile\"), function (expr) {\n    var body = LISP._getRestArgs(arguments, 1);return function (loop) {\n      return LISP.list(LISP.intern(\"let\"), loop, LISP.nil, LISP.list(LISP.intern(\"let1\"), LISP.intern(\"it\"), expr, LISP[\"list*\"](LISP.intern(\"when\"), LISP.intern(\"it\"), LISP.append(body, LISP.list(LISP.list(loop))))));\n    }(LISP.gensym());\n  });\n  LISP[\"null?\"] = function (x) {\n    return LISP[\"eq?\"](x, LISP.nil);\n  };\n  LISP.not = function (x) {\n    return LISP[\"eq?\"](x, LISP.nil);\n  };\n  LISP.caar = function (x) {\n    return LISP.car(LISP.car(x));\n  };\n  LISP.cadr = function (x) {\n    return LISP.car(LISP.cdr(x));\n  };\n  LISP.cdar = function (x) {\n    return LISP.cdr(LISP.car(x));\n  };\n  LISP.cddr = function (x) {\n    return LISP.cdr(LISP.cdr(x));\n  };\n  LISP.cadar = function (x) {\n    return LISP.cadr(LISP.car(x));\n  };\n  LISP.caddr = function (x) {\n    return LISP.car(LISP.cddr(x));\n  };\n  LISP.cdddr = function (x) {\n    return LISP.cdr(LISP.cddr(x));\n  };\n  LISP[\"equal?\"] = function (x, y) {\n    return LISP.isTrue(LISP[\"eq?\"](x, y)) ? LISP.t : function (xtype) {\n      return LISP.isTrue(LISP[\"eq?\"](xtype, LISP.type(y))) ? function (__4) {\n        return LISP.isTrue(LISP[\"eq?\"](__4, LISP.intern(\"pair\"))) ? LISP.isTrue(LISP[\"equal?\"](LISP.car(x), LISP.car(y))) ? LISP[\"equal?\"](LISP.cdr(x), LISP.cdr(y)) : LISP.nil : LISP.isTrue(LISP[\"eq?\"](__4, LISP.intern(\"vector\"))) ? function (n) {\n          return LISP.isTrue(LISP[\"eq?\"](n, LISP[\"vector-length\"](y))) ? function (_loop) {\n            return _loop = function loop(i) {\n              return function (__5) {\n                return LISP.isTrue(__5) ? __5 : LISP.isTrue(LISP[\"equal?\"](LISP[\"vector-ref\"](x, i), LISP[\"vector-ref\"](y, i))) ? _loop(i + 1) : LISP.nil;\n              }(LISP[\">=\"](i, n));\n            }, _loop(0);\n          }(LISP.nil) : LISP.nil;\n        }(LISP[\"vector-length\"](x)) : LISP.nil;\n      }(xtype) : LISP.nil;\n    }(LISP.type(x));\n  };\n  LISP.length = function (ls) {\n    return function (_loop2) {\n      return _loop2 = function loop(ls, acc) {\n        return LISP.isTrue(LISP[\"pair?\"](ls)) ? _loop2(LISP.cdr(ls), acc + 1) : acc;\n      }, _loop2(ls, 0);\n    }(LISP.nil);\n  };\n  LISP[\"last-pair\"] = function (ls) {\n    return LISP.isTrue(LISP[\"pair?\"](LISP.cdr(ls))) ? LISP[\"last-pair\"](LISP.cdr(ls)) : ls;\n  };\n  LISP.member = function (x, ls) {\n    return LISP.isTrue(LISP[\"null?\"](ls)) ? LISP.nil : LISP.isTrue(LISP[\"eq?\"](x, LISP.car(ls))) ? ls : LISP.member(x, LISP.cdr(ls));\n  };\n  LISP.assoc = function (x, ls) {\n    return LISP.isTrue(LISP[\"null?\"](ls)) ? LISP.nil : LISP.isTrue(LISP[\"eq?\"](x, LISP.caar(ls))) ? LISP.car(ls) : LISP.assoc(x, LISP.cdr(ls));\n  };\n  LISP.acons = function (key, datum, alist) {\n    return LISP.cons(LISP.cons(key, datum), alist);\n  };\n  LISP.map = function (f, ls) {\n    return LISP.isTrue(LISP[\"null?\"](ls)) ? LISP.nil : LISP.cons(f(LISP.car(ls)), LISP.map(f, LISP.cdr(ls)));\n  };\n  LISP.append = function (ls) {\n    var rest = LISP._getRestArgs(arguments, 1);return LISP.isTrue(LISP[\"null?\"](rest)) ? ls : LISP.isTrue(LISP[\"null?\"](ls)) ? LISP.apply(LISP.append, rest) : LISP.cons(LISP.car(ls), LISP.apply(LISP.append, LISP.cdr(ls), rest));\n  };\n  LISP.reverse = function (ls) {\n    return function (_loop3) {\n      return _loop3 = function loop(ls, acc) {\n        return LISP.isTrue(LISP[\"pair?\"](ls)) ? _loop3(LISP.cdr(ls), LISP.cons(LISP.car(ls), acc)) : acc;\n      }, _loop3(ls, LISP.nil);\n    }(LISP.nil);\n  };\n  LISP[\"list*\"] = function () {\n    var args = LISP._getRestArgs(arguments, 0);return LISP.isTrue(LISP[\"null?\"](args)) ? LISP.nil : LISP.isTrue(LISP[\"null?\"](LISP.cdr(args))) ? LISP.car(args) : function (_loop4) {\n      return _loop4 = function loop(p, q) {\n        return LISP.isTrue(LISP[\"null?\"](LISP.cdr(q))) ? function () {\n          return LISP[\"set-cdr!\"](p, LISP.car(q)), args;\n        }() : _loop4(q, LISP.cdr(q));\n      }, _loop4(args, LISP.cdr(args));\n    }(LISP.nil);\n  };\n  LISP[\"last-pair\"] = function (ls) {\n    return LISP.isTrue(LISP[\"pair?\"](LISP.cdr(ls))) ? LISP[\"last-pair\"](LISP.cdr(ls)) : ls;\n  };\n  LISP[\"proper-list?\"] = function (ls) {\n    return LISP.isTrue(LISP[\"pair?\"](ls)) ? LISP[\"null?\"](LISP.cdr(LISP[\"last-pair\"](ls))) : LISP.nil;\n  };\n  LISP[\"dotted->proper\"] = function (ls) {\n    return LISP.isTrue(LISP[\"pair?\"](ls)) ? LISP.isTrue(LISP[\"proper-list?\"](ls)) ? ls : function (dot, rev) {\n      return function (dup) {\n        return LISP[\"set-cdr!\"](rev, LISP.list(dot)), dup;\n      }(LISP[\"reverse!\"](rev));\n    }(LISP.cdr(LISP[\"last-pair\"](ls)), LISP.reverse(ls)) : LISP.list(ls);\n  };\n  LISP[\"vector->list\"] = function (vect) {\n    return function (_loop5) {\n      return _loop5 = function loop(i, acc) {\n        return LISP.isTrue(LISP[\"<\"](i, 0)) ? acc : _loop5(i - 1, LISP.cons(LISP[\"vector-ref\"](vect, i), acc));\n      }, _loop5(LISP[\"vector-length\"](vect) - 1, LISP.nil);\n    }(LISP.nil);\n  };\n  LISP[\"position-if\"] = function (pred, seq) {\n    return function (_loop6) {\n      return _loop6 = function loop(p, i) {\n        return LISP.isTrue(p) ? LISP.isTrue(pred(LISP.car(p))) ? i : _loop6(LISP.cdr(p), i + 1) : LISP.nil;\n      }, _loop6(seq, 0);\n    }(LISP.nil);\n  };\n  LISP.take = function (n, ls) {\n    return function (_loop7) {\n      return _loop7 = function loop(n, ls, acc) {\n        return LISP.isTrue(function (__6) {\n          return LISP.isTrue(__6) ? __6 : LISP[\"null?\"](ls);\n        }(LISP[\"<=\"](n, 0))) ? LISP[\"reverse!\"](acc) : _loop7(n - 1, LISP.cdr(ls), LISP.cons(LISP.car(ls), acc));\n      }, _loop7(n, ls, LISP.nil);\n    }(LISP.nil);\n  };\n  LISP.drop = function (n, ls) {\n    return LISP.isTrue(function (__7) {\n      return LISP.isTrue(__7) ? __7 : LISP[\"null?\"](ls);\n    }(LISP[\"<=\"](n, 0))) ? ls : LISP.drop(n - 1, LISP.cdr(ls));\n  };\n  LISP.elt = function (n, ls) {\n    return LISP.car(LISP.drop(n, ls));\n  };\n  LISP[\"remove-if\"] = function (test, seq) {\n    return function (_loop8) {\n      return _loop8 = function loop(seq, acc) {\n        return LISP.isTrue(LISP[\"null?\"](seq)) ? LISP[\"reverse!\"](acc) : _loop8(LISP.cdr(seq), LISP.isTrue(test(LISP.car(seq))) ? acc : LISP.cons(LISP.car(seq), acc));\n      }, _loop8(seq, LISP.nil);\n    }(LISP.nil);\n  };\n  LISP[\"register-macro\"](LISP.intern(\"dotimes\"), function (params) {\n    var body = LISP._getRestArgs(arguments, 1);return function () {\n      var __8 = LISP.list(0),\n          __9 = LISP.list(1);return function (i, limit, loop) {\n        return LISP.list(LISP.intern(\"let1\"), limit, LISP.cadr(params), LISP.list(LISP.intern(\"let\"), loop, LISP.list(LISP[\"list*\"](i, __8)), LISP.list(LISP.intern(\"if\"), LISP.list(LISP.intern(\"<\"), i, limit), LISP[\"list*\"](LISP.intern(\"progn\"), LISP.append(body, LISP.list(LISP.list(loop, LISP[\"list*\"](LISP.intern(\"+\"), i, __9))))), LISP.caddr(params))));\n      };\n    }()(LISP.car(params), LISP.gensym(), LISP.gensym());\n  });\n  LISP[\"register-macro\"](LISP.intern(\"dolist\"), function (pair) {\n    var body = LISP._getRestArgs(arguments, 1);return function (i, loop, ls) {\n      return LISP.list(LISP.intern(\"let\"), loop, LISP.list(LISP.list(ls, LISP.cadr(pair))), LISP.list(LISP.intern(\"let1\"), i, LISP.list(LISP.intern(\"car\"), ls), LISP[\"list*\"](LISP.intern(\"when\"), i, LISP.append(body, LISP.list(LISP.list(loop, LISP.list(LISP.intern(\"cdr\"), ls)))))));\n    }(LISP.car(pair), LISP.gensym(), LISP.gensym());\n  });\n  LISP[\"register-macro\"](LISP.intern(\"labels\"), function (lss) {\n    var body = LISP._getRestArgs(arguments, 1);return LISP[\"list*\"](LISP.intern(\"let\"), LISP.map(function (ls) {\n      return LISP.car(ls);\n    }, lss), LISP.append(LISP.map(function (ls) {\n      return LISP.list(LISP.intern(\"set!\"), LISP.car(ls), LISP[\"list*\"](LISP.intern(\"lambda\"), LISP.cdr(ls)));\n    }, lss), body));\n  });\n  LISP[\"register-macro\"](LISP.intern(\"deftype?\"), function () {\n    var types = LISP._getRestArgs(arguments, 0);return LISP[\"list*\"](LISP.intern(\"progn\"), LISP.map(function () {\n      var __10 = LISP.list(LISP.intern(\"x\")),\n          __11 = LISP.list(LISP.intern(\"type\"), LISP.intern(\"x\"));return function (tt) {\n        return LISP.list(LISP.intern(\"defun\"), LISP.intern(LISP[\"string-append\"](tt, \"?\")), __10, LISP.list(LISP.intern(\"eq?\"), __11, LISP.list(LISP.intern(\"quote\"), tt)));\n      };\n    }(), types));\n  });\n  (function () {\n    return LISP[\"symbol?\"] = function (x) {\n      return LISP[\"eq?\"](LISP.type(x), LISP.intern(\"symbol\"));\n    }, LISP[\"pair?\"] = function (x) {\n      return LISP[\"eq?\"](LISP.type(x), LISP.intern(\"pair\"));\n    }, LISP[\"number?\"] = function (x) {\n      return LISP[\"eq?\"](LISP.type(x), LISP.intern(\"number\"));\n    }, LISP[\"string?\"] = function (x) {\n      return LISP[\"eq?\"](LISP.type(x), LISP.intern(\"string\"));\n    }, LISP[\"keyword?\"] = function (x) {\n      return LISP[\"eq?\"](LISP.type(x), LISP.intern(\"keyword\"));\n    }, LISP[\"vector?\"] = function (x) {\n      return LISP[\"eq?\"](LISP.type(x), LISP.intern(\"vector\"));\n    }, LISP[\"table?\"] = function (x) {\n      return LISP[\"eq?\"](LISP.type(x), LISP.intern(\"table\"));\n    }, LISP[\"regexp?\"] = function (x) {\n      return LISP[\"eq?\"](LISP.type(x), LISP.intern(\"regexp\"));\n    };\n  })();\n  LISP.nreconc = function (ls, tail) {\n    return function (top) {\n      return LISP[\"set-cdr!\"](ls, tail), top;\n    }(LISP[\"reverse!\"](ls));\n  };\n  LISP.any = function (f, ls) {\n    return LISP.isTrue(LISP[\"null?\"](ls)) ? LISP.nil : LISP.isTrue(f(LISP.car(ls))) ? LISP.t : LISP.any(f, LISP.cdr(ls));\n  };\n  LISP.every = function (f, ls) {\n    return LISP.isTrue(LISP[\"null?\"](ls)) ? LISP.t : LISP.isTrue(f(LISP.car(ls))) ? LISP.every(f, LISP.cdr(ls)) : LISP.nil;\n  };\n  LISP[\"*bq-clobberable*\"] = LISP.gensym();\n  LISP[\"*bq-quote-nil*\"] = LISP.list(LISP.intern(\"quote\"), LISP.nil);\n  LISP[\"register-macro\"](LISP.intern(\"quasiquote\"), function (x) {\n    return LISP[\"bq-completely-process\"](x);\n  });\n  LISP[\"bq-completely-process\"] = function (x) {\n    return LISP[\"bq-simplify\"](LISP[\"bq-process\"](x));\n  };\n  LISP[\"bq-process\"] = function (x) {\n    return LISP.isTrue(LISP.not(LISP[\"pair?\"](x))) ? LISP.list(LISP.intern(\"quote\"), x) : LISP.isTrue(LISP[\"eq?\"](LISP.car(x), LISP.intern(\"quasiquote\"))) ? LISP[\"bq-process\"](LISP[\"bq-completely-process\"](LISP.cadr(x))) : LISP.isTrue(LISP[\"eq?\"](LISP.car(x), LISP.intern(\"unquote\"))) ? LISP.cadr(x) : LISP.isTrue(LISP[\"eq?\"](LISP.car(x), LISP.intern(\"unquote-splicing\"))) ? LISP.error(\",@~S after `\", LISP.cadr(x)) : LISP.isTrue(LISP[\"eq?\"](LISP.car(x), LISP.intern(\"unquote-dot\"))) ? LISP.error(\",.~S after `\", LISP.cadr(x)) : function (_loop9) {\n      return _loop9 = function loop(p, q) {\n        return LISP.isTrue(LISP.not(LISP[\"pair?\"](p))) ? LISP.cons(LISP.intern(\"append\"), LISP.nreconc(q, LISP.list(LISP.list(LISP.intern(\"quote\"), p)))) : LISP.isTrue(LISP[\"eq?\"](LISP.car(p), LISP.intern(\"unquote\"))) ? function () {\n          return LISP.isTrue(LISP[\"null?\"](LISP.cddr(p))) ? LISP.nil : LISP.error(\"Malformed ,~S\", p), LISP.cons(LISP.intern(\"append\"), LISP.nreconc(q, LISP.list(LISP.cadr(p))));\n        }() : function () {\n          return LISP.isTrue(LISP[\"eq?\"](LISP.car(p), LISP.intern(\"unquote-splicing\"))) ? LISP.error(\"Dotted ,@~S\", p) : LISP.nil, LISP.isTrue(LISP[\"eq?\"](LISP.car(p), LISP.intern(\"unquote-dot\"))) ? LISP.error(\"Dotted ,.~S\", p) : LISP.nil, _loop9(LISP.cdr(p), LISP.cons(LISP.bracket(LISP.car(p)), q));\n        }();\n      }, _loop9(x, LISP.nil);\n    }(LISP.nil);\n  };\n  LISP.bracket = function (x) {\n    return LISP.isTrue(LISP.not(LISP[\"pair?\"](x))) ? LISP.list(LISP.intern(\"list\"), LISP[\"bq-process\"](x)) : LISP.isTrue(LISP[\"eq?\"](LISP.car(x), LISP.intern(\"unquote\"))) ? LISP.list(LISP.intern(\"list\"), LISP.cadr(x)) : LISP.isTrue(LISP[\"eq?\"](LISP.car(x), LISP.intern(\"unquote-splicing\"))) ? LISP.cadr(x) : LISP.isTrue(LISP[\"eq?\"](LISP.car(x), LISP.intern(\"unquote-dot\"))) ? LISP.list(LISP[\"*bq-clobberable*\"], LISP.cadr(x)) : LISP.list(LISP.intern(\"list\"), LISP[\"bq-process\"](x));\n  };\n  LISP.maptree = function (fn, x) {\n    return LISP.isTrue(LISP.not(LISP[\"pair?\"](x))) ? fn(x) : function (a, d) {\n      return LISP.isTrue(LISP.isTrue(LISP[\"equal?\"](a, LISP.car(x))) ? LISP[\"equal?\"](d, LISP.cdr(x)) : LISP.nil) ? x : LISP.cons(a, d);\n    }(fn(LISP.car(x)), LISP.maptree(fn, LISP.cdr(x)));\n  };\n  LISP[\"bq-splicing-frob\"] = function (x) {\n    return LISP.isTrue(LISP[\"pair?\"](x)) ? function (__12) {\n      return LISP.isTrue(__12) ? __12 : LISP[\"eq?\"](LISP.car(x), LISP.intern(\"unquote-dot\"));\n    }(LISP[\"eq?\"](LISP.car(x), LISP.intern(\"unquote-splicing\"))) : LISP.nil;\n  };\n  LISP[\"bq-frob\"] = function (x) {\n    return LISP.isTrue(LISP[\"pair?\"](x)) ? function (__13) {\n      return LISP.isTrue(__13) ? __13 : function (__14) {\n        return LISP.isTrue(__14) ? __14 : LISP[\"eq?\"](LISP.car(x), LISP.intern(\"unquote-dot\"));\n      }(LISP[\"eq?\"](LISP.car(x), LISP.intern(\"unquote-splicing\")));\n    }(LISP[\"eq?\"](LISP.car(x), LISP.intern(\"unquote\"))) : LISP.nil;\n  };\n  LISP[\"bq-simplify\"] = function (x) {\n    return LISP.isTrue(LISP[\"pair?\"](x)) ? function (x) {\n      return LISP.isTrue(LISP.not(LISP[\"eq?\"](LISP.car(x), LISP.intern(\"append\")))) ? x : LISP[\"bq-simplify-args\"](x);\n    }(LISP.isTrue(LISP[\"eq?\"](LISP.car(x), LISP.intern(\"quote\"))) ? x : LISP.maptree(LISP[\"bq-simplify\"], x)) : x;\n  };\n  LISP[\"bq-simplify-args\"] = function (x) {\n    return function (_loop10) {\n      return _loop10 = function loop(args, result) {\n        return LISP.isTrue(LISP.not(LISP[\"null?\"](args))) ? _loop10(LISP.cdr(args), LISP.isTrue(LISP.not(LISP[\"pair?\"](LISP.car(args)))) ? LISP[\"bq-attach-append\"](LISP.intern(\"append\"), LISP.car(args), result) : LISP.isTrue(LISP.isTrue(LISP[\"eq?\"](LISP.caar(args), LISP.intern(\"list\"))) ? LISP.not(LISP.any(LISP[\"bq-splicing-frob\"], LISP.cdar(args))) : LISP.nil) ? LISP[\"bq-attach-conses\"](LISP.cdar(args), result) : LISP.isTrue(LISP.isTrue(LISP[\"eq?\"](LISP.caar(args), LISP.intern(\"list*\"))) ? LISP.not(LISP.any(LISP[\"bq-splicing-frob\"], LISP.cdar(args))) : LISP.nil) ? LISP[\"bq-attach-conses\"](LISP.reverse(LISP.cdr(LISP.reverse(LISP.cdar(args)))), LISP[\"bq-attach-append\"](LISP.intern(\"append\"), LISP.car(LISP.last(LISP.car(args))), result)) : LISP.isTrue(LISP.isTrue(LISP[\"eq?\"](LISP.caar(args), LISP.intern(\"quote\"))) ? LISP.isTrue(LISP[\"pair?\"](LISP.cadar(args))) ? LISP.isTrue(LISP.not(LISP[\"bq-frob\"](LISP.cadar(args)))) ? LISP.not(LISP.cddar(args)) : LISP.nil : LISP.nil : LISP.nil) ? LISP[\"bq-attach-conses\"](LISP.list(LISP.list(LISP.intern(\"quote\"), LISP.caadar(args))), result) : LISP.isTrue(LISP[\"eq?\"](LISP.caar(args), LISP[\"*bq-clobberable*\"])) ? LISP[\"bq-attach-append\"](LISP.intern(\"append!\"), LISP.cadar(args), result) : LISP[\"bq-attach-append\"](LISP.intern(\"append\"), LISP.car(args), result)) : result;\n      }, _loop10(LISP.reverse(LISP.cdr(x)), LISP.nil);\n    }(LISP.nil);\n  };\n  LISP[\"null-or-quoted\"] = function (x) {\n    return function (__15) {\n      return LISP.isTrue(__15) ? __15 : LISP.isTrue(LISP[\"pair?\"](x)) ? LISP[\"eq?\"](LISP.car(x), LISP.intern(\"quote\")) : LISP.nil;\n    }(LISP[\"null?\"](x));\n  };\n  LISP[\"bq-attach-append\"] = function (op, item, result) {\n    return LISP.isTrue(LISP.isTrue(LISP[\"null-or-quoted\"](item)) ? LISP[\"null-or-quoted\"](result) : LISP.nil) ? LISP.list(LISP.intern(\"quote\"), LISP.append(LISP.cadr(item), LISP.cadr(result))) : LISP.isTrue(function (__16) {\n      return LISP.isTrue(__16) ? __16 : LISP[\"equal?\"](result, LISP[\"*bq-quote-nil*\"]);\n    }(LISP[\"null?\"](result))) ? LISP.isTrue(LISP[\"bq-splicing-frob\"](item)) ? LISP.list(op, item) : item : LISP.isTrue(LISP.isTrue(LISP[\"pair?\"](result)) ? LISP[\"eq?\"](LISP.car(result), op) : LISP.nil) ? LISP[\"list*\"](LISP.car(result), item, LISP.cdr(result)) : LISP.list(op, item, result);\n  };\n  LISP[\"bq-attach-conses\"] = function (items, result) {\n    return LISP.isTrue(LISP.isTrue(LISP.every(LISP[\"null-or-quoted\"], items)) ? LISP[\"null-or-quoted\"](result) : LISP.nil) ? LISP.list(LISP.intern(\"quote\"), LISP.append(LISP.map(LISP.cadr, items), LISP.cadr(result))) : LISP.isTrue(function (__17) {\n      return LISP.isTrue(__17) ? __17 : LISP[\"equal?\"](result, LISP[\"*bq-quote-nil*\"]);\n    }(LISP[\"null?\"](result))) ? LISP.cons(LISP.intern(\"list\"), items) : LISP.isTrue(LISP.isTrue(LISP[\"pair?\"](result)) ? function (__18) {\n      return LISP.isTrue(__18) ? __18 : LISP[\"eq?\"](LISP.car(result), LISP.intern(\"list*\"));\n    }(LISP[\"eq?\"](LISP.car(result), LISP.intern(\"list\"))) : LISP.nil) ? LISP.cons(LISP.car(result), LISP.append(items, LISP.cdr(result))) : LISP.cons(LISP.intern(\"list*\"), LISP.append(items, LISP.list(result)));\n  };\n  LISP[\"create-scope\"] = function (parent$2dscope, params) {\n    return LISP.vector(LISP[\"remove-if\"](function () {\n      var __19 = LISP.list(LISP.intern(\"&rest\"), LISP.intern(\"&body\"));return function (x) {\n        return LISP.member(x, __19);\n      };\n    }(), params), LISP.nil, parent$2dscope);\n  };\n  LISP[\"scope-param\"] = function (scope) {\n    return LISP[\"vector-ref\"](scope, 0);\n  };\n  LISP[\"scope-outer\"] = function (scope) {\n    return LISP[\"vector-ref\"](scope, 2);\n  };\n  LISP[\"scope-add-var\"] = function (scope, val) {\n    return function (x) {\n      return LISP[\"vector-set!\"](scope, 1, LISP.cons(LISP.cons(x, val), LISP[\"vector-ref\"](scope, 1))), LISP[\"vector-set!\"](scope, 0, LISP.cons(x, LISP[\"vector-ref\"](scope, 0))), x;\n    }(LISP.gensym());\n  };\n  LISP[\"scope-get-var\"] = function (scope) {\n    return LISP[\"vector-ref\"](scope, 1);\n  };\n  LISP[\"scope-var?\"] = function (scope, x) {\n    return LISP.isTrue(LISP[\"null?\"](scope)) ? LISP.nil : LISP.isTrue(LISP.member(x, LISP[\"scope-param\"](scope))) ? LISP.t : LISP[\"scope-var?\"](LISP[\"scope-outer\"](scope), x);\n  };\n  LISP[\"local-var?\"] = function (scope, sym) {\n    return LISP.isTrue(LISP[\"symbol?\"](sym)) ? LISP[\"scope-var?\"](scope, LISP[\"get-receiver\"](sym)) : LISP.nil;\n  };\n  LISP[\"special-var?\"] = function () {\n    var __20 = LISP.list(LISP.intern(\"this\"));return function (scope, sym) {\n      return LISP.member(sym, __20);\n    };\n  }();\n  LISP[\"get-receiver\"] = function (sym) {\n    return function (s) {\n      return function (it) {\n        return LISP.isTrue(it) ? LISP.intern(LISP.substring(s, 0, it)) : sym;\n      }(LISP[\"string-scan\"](s, \".\"));\n    }(LISP[\"symbol->string\"](sym));\n  };\n  LISP[\"register-macro\"](LISP.intern(\"record\"), function (args, param) {\n    var body = LISP._getRestArgs(arguments, 2);return LISP.list(LISP.intern(\"apply\"), LISP[\"list*\"](LISP.intern(\"lambda\"), param, body), args);\n  });\n  LISP[\"register-macro\"](LISP.intern(\"record-case\"), function (x) {\n    var clauses = LISP._getRestArgs(arguments, 1);return function (value) {\n      return LISP.list(LISP.intern(\"let1\"), value, x, LISP[\"list*\"](LISP.intern(\"case\"), LISP.list(LISP.intern(\"car\"), value), LISP.map(function (clause) {\n        return LISP.isTrue(LISP[\"eq?\"](LISP.car(clause), LISP.t)) ? clause : function (key) {\n          return LISP.list(LISP.list(key), LISP[\"list*\"](LISP.intern(\"record\"), LISP.list(LISP.intern(\"cdr\"), value), LISP.cdar(clause), LISP.cdr(clause)));\n        }(LISP.caar(clause));\n      }, clauses)));\n    }(LISP.gensym());\n  });\n  (function (traverse$2dargs, _confirm$2dvalid$2dparams, _traverse$2dquoted$2dvalue) {\n    return traverse$2dargs = function traverse$2dargs(args, scope) {\n      return LISP.map(function (x) {\n        return LISP[\"traverse*\"](x, scope);\n      }, args);\n    }, _confirm$2dvalid$2dparams = function confirm$2dvalid$2dparams(params) {\n      return LISP.isTrue(params) ? LISP.isTrue(LISP[\"symbol?\"](LISP.car(params))) ? _confirm$2dvalid$2dparams(LISP.cdr(params)) : LISP[\"compile-error\"](\"function parameter must be symbol, but\", LISP.car(params)) : LISP.nil;\n    }, _traverse$2dquoted$2dvalue = function traverse$2dquoted$2dvalue(x) {\n      return LISP.isTrue(LISP[\"pair?\"](x)) ? LISP.vector(LISP[\"make-keyword\"](\"FUNCALL\"), LISP.vector(LISP[\"make-keyword\"](\"REF\"), LISP.isTrue(LISP[\"proper-list?\"](x)) ? LISP.intern(\"list\") : LISP.intern(\"list*\")), LISP.map(_traverse$2dquoted$2dvalue, LISP[\"dotted->proper\"](x))) : LISP.vector(LISP[\"make-keyword\"](\"CONST\"), x);\n    }, LISP[\"traverse-list\"] = function (s, scope) {\n      return function (__21) {\n        return function (__22) {\n          return LISP.isTrue(LISP[\"eq?\"](__22, LISP.intern(\"quote\"))) ? LISP.apply(function (x) {\n            return LISP.isTrue(LISP[\"pair?\"](x)) ? LISP.vector(LISP[\"make-keyword\"](\"REF\"), LISP[\"scope-add-var\"](scope, _traverse$2dquoted$2dvalue(x))) : LISP.vector(LISP[\"make-keyword\"](\"CONST\"), x);\n          }, LISP.cdr(__21)) : LISP.isTrue(LISP[\"eq?\"](__22, LISP.intern(\"if\"))) ? LISP.apply(function (p, thn) {\n            var els = LISP._getRestArgs(arguments, 2);return LISP.vector(LISP[\"make-keyword\"](\"IF\"), LISP[\"traverse*\"](p, scope), LISP[\"traverse*\"](thn, scope), LISP.isTrue(LISP[\"null?\"](els)) ? LISP.nil : LISP[\"traverse*\"](LISP.car(els), scope));\n          }, LISP.cdr(__21)) : LISP.isTrue(LISP[\"eq?\"](__22, LISP.intern(\"set!\"))) ? LISP.apply(function (x, v) {\n            return LISP.vector(LISP[\"make-keyword\"](\"SET!\"), LISP[\"traverse*\"](x, scope), LISP[\"traverse*\"](v, scope));\n          }, LISP.cdr(__21)) : LISP.isTrue(LISP[\"eq?\"](__22, LISP.intern(\"lambda\"))) ? LISP.apply(function (params) {\n            var body = LISP._getRestArgs(arguments, 1);return function () {\n              return _confirm$2dvalid$2dparams(params), function (new$2dscope) {\n                return LISP.vector(LISP[\"make-keyword\"](\"LAMBDA\"), new$2dscope, params, traverse$2dargs(body, new$2dscope));\n              }(LISP[\"create-scope\"](scope, params));\n            }();\n          }, LISP.cdr(__21)) : LISP.isTrue(LISP[\"eq?\"](__22, LISP.intern(\"def\"))) ? LISP.apply(function (name, value) {\n            return LISP.vector(LISP[\"make-keyword\"](\"DEF\"), LISP[\"traverse*\"](name, scope), LISP[\"traverse*\"](value, scope));\n          }, LISP.cdr(__21)) : LISP.isTrue(LISP[\"eq?\"](__22, LISP.intern(\"new\"))) ? LISP.apply(function (klass) {\n            var args = LISP._getRestArgs(arguments, 1);return LISP.vector(LISP[\"make-keyword\"](\"NEW\"), klass, traverse$2dargs(args, LISP[\"new-scope\"]));\n          }, LISP.cdr(__21)) : LISP.vector(LISP[\"make-keyword\"](\"FUNCALL\"), LISP[\"traverse*\"](LISP.car(s), scope), traverse$2dargs(LISP.cdr(s), scope));\n        }(LISP.car(__21));\n      }(s);\n    };\n  })(LISP.nil, LISP.nil, LISP.nil);\n  LISP[\"traverse*\"] = function (s, scope) {\n    return LISP.isTrue(LISP[\"pair?\"](s)) ? LISP.isTrue(LISP[\"local-var?\"](scope, LISP.car(s))) ? LISP[\"traverse-list\"](s, scope) : function (expanded) {\n      return LISP.isTrue(LISP[\"pair?\"](expanded)) ? LISP[\"traverse-list\"](expanded, scope) : LISP[\"traverse*\"](expanded, scope);\n    }(LISP.macroexpand(s)) : LISP.isTrue(LISP[\"symbol?\"](s)) ? LISP.vector(LISP[\"make-keyword\"](\"REF\"), s) : LISP.vector(LISP[\"make-keyword\"](\"CONST\"), s);\n  };\n  LISP[\"expand-args\"] = function (args, scope) {\n    return LISP[\"string-join\"](LISP.map(function (x) {\n      return LISP[\"compile*\"](x, scope);\n    }, args), \", \");\n  };\n  LISP[\"expand-body\"] = function (body, scope) {\n    return LISP.isTrue(LISP[\"null?\"](body)) ? \"LISP.nil\" : LISP[\"expand-args\"](body, scope);\n  };\n  (function (table) {\n    return LISP[\"hash-table-put!\"](table, \"\\\\\", \"\\\\\\\\\"), LISP[\"hash-table-put!\"](table, \"\\t\", \"\\\\t\"), LISP[\"hash-table-put!\"](table, \"\\n\", \"\\\\n\"), LISP[\"hash-table-put!\"](table, \"\\\"\", \"\\\\\\\"\"), LISP[\"escape-char\"] = function (c) {\n      return function (__23) {\n        return LISP.isTrue(__23) ? __23 : c;\n      }(LISP[\"hash-table-get\"](table, c));\n    };\n  })(LISP[\"make-hash-table\"]());\n  LISP[\"escape-string\"] = function (s) {\n    return LISP[\"regexp-replace-all\"](/[\\\\\\t\\n\"]/, s, function (m) {\n      return LISP[\"escape-char\"](m());\n    });\n  };\n  LISP[\"escape-sym-char\"] = function (c) {\n    return LISP[\"string-append\"](\"$\", LISP[\"integer->hex-string\"](LISP[\"char->integer\"](c), \"00\"));\n  };\n  LISP[\"integer->hex-string\"] = function (x, padding) {\n    return function (s) {\n      return function (sl) {\n        return function (pl) {\n          return LISP.substring(s, sl - pl, sl);\n        }(LISP[\"string-length\"](padding));\n      }(LISP[\"string-length\"](s));\n    }(LISP[\"string-append\"](padding, LISP[\"number->string\"](x, 16)));\n  };\n  LISP[\"escape-symbol\"] = function (sym) {\n    return LISP[\"regexp-replace-all\"](/[^0-9A-Za-z_.]/, LISP[\"symbol->string\"](sym), function (m) {\n      return LISP[\"escape-sym-char\"](LISP[\"string-ref\"](m(), 0));\n    });\n  };\n  LISP[\"compile-symbol\"] = function (sym, scope) {\n    return LISP.isTrue(function (__24) {\n      return LISP.isTrue(__24) ? __24 : LISP[\"special-var?\"](scope, sym);\n    }(LISP[\"local-var?\"](scope, sym))) ? LISP[\"escape-symbol\"](sym) : function (s) {\n      return LISP.isTrue(LISP.rxmatch(/^[0-9A-Za-z_.]*$/, s)) ? LISP[\"string-append\"](\"LISP.\", s) : LISP[\"string-append\"](\"LISP[\\\"\", LISP[\"escape-string\"](s), \"\\\"]\");\n    }(LISP[\"symbol->string\"](sym));\n  };\n  LISP[\"compile-keyword\"] = function (keyword) {\n    return LISP[\"string-append\"](\"LISP[\\\"make-keyword\\\"](\\\"\", LISP[\"escape-string\"](LISP[\"keyword->string\"](keyword)), \"\\\")\");\n  };\n  LISP[\"compile-vector\"] = function (vect, scope) {\n    return LISP[\"string-append\"](\"[\", LISP[\"string-join\"](LISP.map(function (x) {\n      return LISP[\"compile-quote\"](x, scope);\n    }, LISP[\"vector->list\"](vect)), \", \"), \"]\");\n  };\n  LISP[\"compile-regexp\"] = function (regex) {\n    return LISP[\"string-append\"](\"/\", LISP[\"regexp->string\"](regex), \"/\");\n  };\n  LISP[\"compile-literal\"] = function (s, scope) {\n    return LISP.isTrue(LISP[\"number?\"](s)) ? LISP[\"number->string\"](s) : LISP.isTrue(LISP[\"symbol?\"](s)) ? LISP[\"compile-symbol\"](s, scope) : LISP.isTrue(LISP[\"keyword?\"](s)) ? LISP[\"compile-keyword\"](s) : LISP.isTrue(LISP[\"string?\"](s)) ? LISP[\"x->string\"](s, LISP.t) : LISP.isTrue(LISP[\"vector?\"](s)) ? LISP[\"compile-vector\"](s, scope) : LISP.isTrue(LISP[\"regexp?\"](s)) ? LISP[\"compile-regexp\"](s) : LISP.isTrue(LISP[\"null?\"](s)) ? \"LISP.nil\" : LISP.isTrue(LISP[\"eq?\"](s, LISP.t)) ? \"LISP.t\" : LISP.error(LISP[\"string-append\"](\"compile-literal: [\", s, \"]\"));\n  };\n  LISP[\"unary-op?\"] = function () {\n    var __25 = LISP.list(LISP.intern(\"+\"), LISP.intern(\"-\"), LISP.intern(\"!\"), LISP.intern(\"~\"));return function (sym) {\n      return LISP.member(sym, __25);\n    };\n  }();\n  LISP[\"compile-unary-op\"] = function (fn, arg, scope) {\n    return LISP[\"string-append\"](\"(\", LISP[\"symbol->string\"](fn), LISP[\"compile*\"](arg, scope), \")\");\n  };\n  LISP[\"binop?\"] = function () {\n    var __26 = LISP.list(LISP.intern(\"+\"), LISP.intern(\"-\"), LISP.intern(\"*\"), LISP.intern(\"/\"), LISP.intern(\"%\"));return function (sym) {\n      return LISP.member(sym, __26);\n    };\n  }();\n  LISP[\"compile-binop\"] = function (fn, args, scope) {\n    return LISP[\"string-append\"](\"(\", LISP[\"string-join\"](LISP.map(function (x) {\n      return LISP[\"compile*\"](x, scope);\n    }, args), LISP[\"string-append\"](\" \", LISP[\"symbol->string\"](fn), \" \")), \")\");\n  };\n  LISP[\"do-compile-funcall\"] = function (fn, args, scope) {\n    return LISP[\"string-append\"](LISP[\"compile*\"](fn, scope), \"(\", LISP[\"expand-args\"](args, scope), \")\");\n  };\n  LISP[\"compile-funcall\"] = function (fn, args, scope) {\n    return LISP.isTrue(LISP.isTrue(LISP[\"eq?\"](LISP[\"vector-ref\"](fn, 0), LISP[\"make-keyword\"](\"REF\"))) ? LISP.isTrue(LISP.not(LISP[\"local-var?\"](scope, LISP[\"vector-ref\"](fn, 1)))) ? LISP.not(LISP[\"null?\"](args)) : LISP.nil : LISP.nil) ? function (fnsym) {\n      return LISP.isTrue(LISP.isTrue(LISP[\"binop?\"](fnsym)) ? LISP.not(LISP[\"null?\"](LISP.cdr(args))) : LISP.nil) ? LISP[\"compile-binop\"](fnsym, args, scope) : LISP.isTrue(LISP.isTrue(LISP[\"unary-op?\"](fnsym)) ? LISP[\"null?\"](LISP.cdr(args)) : LISP.nil) ? LISP[\"compile-unary-op\"](fnsym, LISP.car(args), scope) : LISP[\"do-compile-funcall\"](fn, args, scope);\n    }(LISP[\"vector-ref\"](fn, 1)) : LISP[\"do-compile-funcall\"](fn, args, scope);\n  };\n  LISP[\"compile-quote\"] = function (x, scope) {\n    return LISP.isTrue(LISP[\"pair?\"](x)) ? LISP[\"compile*\"](LISP.list(LISP.intern(\"cons\"), LISP.list(LISP.intern(\"quote\"), LISP.car(x)), LISP.list(LISP.intern(\"quote\"), LISP.cdr(x))), scope) : LISP.isTrue(LISP[\"symbol?\"](x)) ? LISP[\"string-append\"](\"LISP.intern(\\\"\", LISP[\"escape-string\"](LISP[\"symbol->string\"](x)), \"\\\")\") : LISP.isTrue(LISP[\"keyword?\"](x)) ? LISP[\"compile-keyword\"](x) : LISP[\"compile-literal\"](x, scope);\n  };\n  LISP[\"compile-if\"] = function (pred$2dnode, then$2dnode, else$2dnode, scope) {\n    return LISP[\"string-append\"](\"(LISP.isTrue(\", LISP[\"compile*\"](pred$2dnode, scope), \") ? (\", LISP[\"compile*\"](then$2dnode, scope), \") : (\", LISP.isTrue(else$2dnode) ? LISP[\"compile*\"](else$2dnode, scope) : \"LISP.nil\", \"))\");\n  };\n  LISP[\"compile-set!\"] = function (sym, val, scope) {\n    return LISP[\"string-append\"](LISP[\"compile*\"](sym, scope), \" = \", LISP[\"compile*\"](val, scope));\n  };\n  LISP[\"compile-lambda\"] = function (params, bodies, base$2dscope, extended$2dscope) {\n    return LISP.isTrue(function (__27) {\n      return LISP.isTrue(__27) ? __27 : LISP[\"pair?\"](params);\n    }(LISP[\"null?\"](params))) ? LISP.nil : LISP.error(\"function parameters must be a list\"), function (rest$2dpos) {\n      return function (proper$2dparams, rest) {\n        return LISP[\"string-append\"](\"(function(\", LISP[\"string-join\"](LISP.map(function (x) {\n          return LISP[\"escape-symbol\"](x);\n        }, proper$2dparams), \", \"), \"){\", LISP.isTrue(LISP[\"null?\"](rest)) ? \"\" : LISP[\"string-append\"](\"var \", LISP[\"escape-symbol\"](rest), \" = LISP._getRestArgs(arguments, \", LISP[\"number->string\"](LISP.length(proper$2dparams)), \"); \"), \"return (\", LISP[\"expand-body\"](bodies, extended$2dscope), \");})\");\n      }(LISP.isTrue(rest$2dpos) ? LISP.take(rest$2dpos, params) : params, LISP.isTrue(rest$2dpos) ? LISP.elt(rest$2dpos + 1, params) : LISP.nil);\n    }(LISP[\"position-if\"](function () {\n      var __28 = LISP.list(LISP.intern(\"&rest\"), LISP.intern(\"&body\"));return function (sym) {\n        return LISP.member(sym, __28);\n      };\n    }(), params));\n  };\n  LISP[\"compile-def\"] = function (name, value, scope) {\n    return LISP[\"string-append\"](LISP[\"compile*\"](name, scope), \" = \", LISP[\"compile*\"](value, scope));\n  };\n  LISP[\"compile-new\"] = function (class$2dname, args, scope) {\n    return LISP[\"string-append\"](\"new \", LISP[\"symbol->string\"](class$2dname), \"(\", LISP[\"expand-args\"](args, scope), \")\");\n  };\n  LISP[\"compile-new-scope\"] = function (compiled$2dbody, scope) {\n    return function (it) {\n      return LISP.isTrue(it) ? LISP[\"string-append\"](\"(function() { var \", LISP[\"string-join\"](LISP.map(function (x) {\n        return LISP[\"string-append\"](LISP[\"escape-symbol\"](LISP.car(x)), \" = \", LISP[\"compile*\"](LISP.cdr(x), scope));\n      }, LISP.reverse(it)), \", \"), \"; return \", compiled$2dbody, \"; })()\") : compiled$2dbody;\n    }(LISP[\"scope-get-var\"](scope));\n  };\n  LISP[\"compile*\"] = function (s, scope) {\n    return function (__29) {\n      return LISP.isTrue(LISP[\"eq?\"](__29, LISP[\"make-keyword\"](\"CONST\"))) ? LISP[\"compile-quote\"](LISP[\"vector-ref\"](s, 1), scope) : LISP.isTrue(LISP[\"eq?\"](__29, LISP[\"make-keyword\"](\"REF\"))) ? LISP[\"compile-symbol\"](LISP[\"vector-ref\"](s, 1), scope) : LISP.isTrue(LISP[\"eq?\"](__29, LISP[\"make-keyword\"](\"IF\"))) ? function (p, thn, els) {\n        return LISP[\"compile-if\"](p, thn, els, scope);\n      }(LISP[\"vector-ref\"](s, 1), LISP[\"vector-ref\"](s, 2), LISP[\"vector-ref\"](s, 3)) : LISP.isTrue(LISP[\"eq?\"](__29, LISP[\"make-keyword\"](\"FUNCALL\"))) ? LISP[\"compile-funcall\"](LISP[\"vector-ref\"](s, 1), LISP[\"vector-ref\"](s, 2), scope) : LISP.isTrue(LISP[\"eq?\"](__29, LISP[\"make-keyword\"](\"SET!\"))) ? LISP[\"compile-set!\"](LISP[\"vector-ref\"](s, 1), LISP[\"vector-ref\"](s, 2), scope) : LISP.isTrue(LISP[\"eq?\"](__29, LISP[\"make-keyword\"](\"LAMBDA\"))) ? function (extended$2dscope, params, body) {\n        return LISP[\"compile-new-scope\"](LISP[\"compile-lambda\"](params, body, scope, extended$2dscope), extended$2dscope);\n      }(LISP[\"vector-ref\"](s, 1), LISP[\"vector-ref\"](s, 2), LISP[\"vector-ref\"](s, 3)) : LISP.isTrue(LISP[\"eq?\"](__29, LISP[\"make-keyword\"](\"DEF\"))) ? LISP[\"compile-def\"](LISP[\"vector-ref\"](s, 1), LISP[\"vector-ref\"](s, 2), scope) : LISP.isTrue(LISP[\"eq?\"](__29, LISP[\"make-keyword\"](\"NEW\"))) ? LISP[\"compile-new\"](LISP[\"vector-ref\"](s, 1), LISP[\"vector-ref\"](s, 2), scope) : LISP[\"compile-error\"](\"Unknown AST node:\", s);\n    }(LISP[\"vector-ref\"](s, 0));\n  };\n  LISP[\"compile-error\"] = function () {\n    var args = LISP._getRestArgs(arguments, 0);return LISP.error(args);\n  };\n  LISP.compile = function (s) {\n    return function (top$2dscope) {\n      return function (tree) {\n        return LISP[\"compile-new-scope\"](LISP[\"compile*\"](tree, top$2dscope), top$2dscope);\n      }(LISP[\"traverse*\"](s, top$2dscope));\n    }(LISP[\"create-scope\"](LISP.nil, LISP.nil));\n  };\n});\n\n","(register-macro 'defmacro\n  (lambda (name params &body body)\n    `(register-macro ',name\n       (lambda ,params ,@body))))\n\n(defun macroexpand (exp)\n  (let ((expanded (macroexpand-1 exp)))\n    (if (equal? expanded exp)\n        exp\n      (macroexpand expanded))))\n\n;; Reader macros\n(set-macro-character \"'\"\n  (lambda (stream _)\n    (list 'quote (read stream))))\n\n(set-macro-character \"`\"\n  (lambda (stream _)\n    (list `quasiquote (read stream))))\n\n(set-macro-character \",\"\n  (lambda (stream _)\n    (let ((c2 (read-char stream)))\n      (if (eq? c2 \"@\")\n          (list 'unquote-splicing (read stream))\n        (progn (unread-char c2 stream)\n               (list 'unquote (read stream)))))))\n\n(defmacro defun (name params &body body)\n  `(def ,name (lambda ,params ,@body)))\n\n(defmacro let (pairs &body body)\n  (if (symbol? pairs)  ; named-let\n      (let ((name pairs)\n            (pairs (car body))\n            (body (cdr body)))\n        `((lambda (,name)\n            (set! ,name (lambda ,(map car pairs)\n                           ,@body))\n            (,name ,@(map cadr pairs)))\n          nil))\n    `((lambda ,(map car pairs)\n         ,@body)\n      ,@(map cadr pairs))))\n\n(defmacro let1 (name value &body body)\n  `(let ((,name ,value))\n     ,@body))\n\n(defmacro let* (pairs &body body)\n  (if (null? pairs)\n      `(progn ,@body)\n    `(let1 ,(caar pairs) ,(cadar pairs)\n       (let* ,(cdr pairs)\n         ,@body))))\n\n(defmacro when (pred &body body)\n  `(if ,pred\n       (progn ,@body)))\n\n(defmacro unless (pred &body body)\n  `(if ,pred\n       nil\n     (progn ,@body)))\n\n(defmacro cond (&body clauses)\n  (if (null? clauses)\n      ()\n    (let ((clause (car clauses))\n          (rest (cdr clauses)))\n      (cond ((eq? (car clause) t)\n             `(progn ,@(cdr clause)))\n            ((null? (cdr clause))  ; cond ((foo))\n             (let ((g (gensym)))\n               `(let ((,g ,(car clause)))\n                  (if ,g ,g\n                    (cond ,@rest)))))\n            ((eq? (cadr clause) '=>)  ; cond ((foo) => bar)\n             (let ((g (gensym)))\n               `(let ((,g ,(car clause)))\n                  (if ,g (,(caddr clause) ,g)\n                    (cond ,@rest)))))\n            (t `(if ,(car clause)  ; otherwise\n                    (progn ,@(cdr clause))\n                  (cond ,@rest)))))))\n\n(defmacro case (x &body clauses)\n  (let1 value (gensym)\n    `(let1 ,value ,x\n       (cond\n        ,@(map (lambda (clause)\n                 (cond ((eq? (car clause) t)\n                        clause)\n                       ((null? (cdar clause))\n                        `((eq? ,value ',(caar clause)) ,@(cdr clause)))\n                       (t `((member ,value ',(car clause)) ,@(cdr clause)))))\n               clauses)))))\n\n(defmacro and (&rest args)\n  (if (null? args)\n      t  ; (and) = true\n    (if (null? (cdr args))\n        (car args)\n      `(if ,(car args)\n           (and ,@(cdr args))\n         nil))))\n\n(defmacro or (&rest args)\n  (if (null? (cdr args))\n      (car args)\n    (let1 g (gensym)\n      `(let1 ,g ,(car args)\n         (if ,g ,g\n           (or ,@(cdr args)))))))\n\n(defmacro progn (&body body)\n  (cond ((null? body) nil)\n        ((null? (cdr body)) (car body))\n        (t `(let ()\n              ,@body))))\n\n(defmacro aif (expr thn &body els)\n  `(let1 it ,expr\n     (if it ,thn ,@els)))\n\n(defmacro awhen (expr &body body)\n  `(aif ,expr\n        (progn ,@body)))\n\n(defmacro awhile (expr &body body)\n  (let ((loop (gensym)))\n    `(let ,loop ()\n          (let1 it ,expr\n            (when it\n              ,@body\n              (,loop))))))\n\n;;\n(defun null? (x)  (eq? x nil))\n(defun not (x)    (eq? x nil))\n\n(defun caar (x)  (car (car x)))\n(defun cadr (x)  (car (cdr x)))\n(defun cdar (x)  (cdr (car x)))\n(defun cddr (x)  (cdr (cdr x)))\n(defun cadar (x)  (cadr (car x)))\n(defun caddr (x)  (car (cddr x)))\n(defun cdddr (x)  (cdr (cddr x)))\n\n(defun equal? (x y)\n  (if (eq? x y)\n      t\n    (let1 xtype (type x)\n      (when (eq? xtype (type y))\n        (case xtype\n          ((pair) (and (equal? (car x) (car y))\n                       (equal? (cdr x) (cdr y))))\n          ((vector) (let1 n (vector-length x)\n                      (and (eq? n (vector-length y))\n                           (let loop ((i 0))\n                             (or (>= i n)\n                                 (and (equal? (vector-ref x i) (vector-ref y i))\n                                      (loop (+ i 1))))))))\n          )))))\n\n(defun length (ls)\n  (let loop ((ls ls)\n             (acc 0))\n    (if (pair? ls)\n        (loop (cdr ls) (+ acc 1))\n      acc)))\n\n(defun last-pair (ls)\n  (if (pair? (cdr ls))\n      (last-pair (cdr ls))\n    ls))\n\n(defun member (x ls)\n  (cond ((null? ls) nil)\n        ((eq? x (car ls)) ls)\n        (t (member x (cdr ls)))))\n\n(defun assoc (x ls)\n  (cond ((null? ls) nil)\n        ((eq? x (caar ls)) (car ls))\n        (t (assoc x (cdr ls)))))\n\n(defun acons (key datum alist)\n  (cons (cons key datum) alist))\n\n(defun map (f ls)\n  (if (null? ls)\n      ()\n    (cons (f (car ls))\n          (map f (cdr ls)))))\n\n(defun append (ls &rest rest)\n  (cond ((null? rest) ls)\n        ((null? ls)   (apply append rest))\n        (t (cons (car ls)\n                 (apply append (cdr ls) rest)))))\n\n(defun reverse (ls)\n  (let loop ((ls ls)\n             (acc ()))\n    (if (pair? ls)\n        (loop (cdr ls)\n              (cons (car ls) acc))\n      acc)))\n\n(defun list* (&rest args)\n  (if (null? args)\n      nil\n    (if (null? (cdr args))\n        (car args)\n      (let loop ((p args)\n                 (q (cdr args)))\n        (if (null? (cdr q))\n            (progn (set-cdr! p (car q))\n                   args)\n          (loop q (cdr q)))))))\n\n(defun last-pair (ls)\n  (if (pair? (cdr ls))\n      (last-pair (cdr ls))\n    ls))\n\n(defun proper-list? (ls)\n  (and (pair? ls)\n       (null? (cdr (last-pair ls)))))\n\n(defun dotted->proper (ls)\n  (if (pair? ls)\n      (if (proper-list? ls)\n          ls\n        (let ((dot (cdr (last-pair ls)))\n              (rev (reverse ls)))\n          (let1 dup (reverse! rev)\n            (set-cdr! rev (list dot))\n            dup)))\n    (list ls)))\n\n(defun vector->list (vect)\n  (let loop ((i (- (vector-length vect) 1))\n             (acc ()))\n       (if (< i 0)\n           acc\n         (loop (- i 1) (cons (vector-ref vect i) acc)))))\n\n(defun position-if (pred seq)\n    (let loop ((p seq)\n               (i 0))\n         (when p\n           (if (pred (car p))\n               i\n             (loop (cdr p) (+ i 1))))))\n\n(defun take (n ls)\n  (let loop ((n n)\n             (ls ls)\n             (acc nil))\n       (if (or (<= n 0)\n               (null? ls))\n           (reverse! acc)\n         (loop (- n 1) (cdr ls) (cons (car ls) acc)))))\n\n(defun drop (n ls)\n  (if (or (<= n 0)\n          (null? ls))\n      ls\n    (drop (- n 1) (cdr ls))))\n\n(defun elt (n ls)\n  (car (drop n ls)))\n\n(defun remove-if (test seq)\n  (let loop ((seq seq)\n             (acc ()))\n       (if (null? seq)\n           (reverse! acc)\n         (loop (cdr seq)\n               (if (test (car seq))\n                   acc\n                 (cons (car seq) acc))))))\n\n(defmacro dotimes (params &body body)\n  (let ((i (car params))\n        (limit (gensym))\n        (loop (gensym)))\n    `(let1 ,limit ,(cadr params)\n       (let ,loop ((,i 0))\n            (if (< ,i ,limit)\n                (progn ,@body\n                       (,loop (+ ,i 1)))\n              ,(caddr params))))))\n\n(defmacro dolist (pair &body body)\n  (let ((i (car pair))\n        (loop (gensym))\n        (ls (gensym)))\n    `(let ,loop ((,ls ,(cadr pair)))\n          (let1 ,i (car ,ls)\n            (when ,i\n              ,@body\n              (,loop (cdr ,ls)))))))\n\n(defmacro labels (lss &body body)\n  `(let ,(map (lambda (ls) (car ls)) lss)\n     ,@(map (lambda (ls)\n              `(set! ,(car ls) (lambda ,@(cdr ls))))\n            lss)\n     ,@body))\n\n(defmacro deftype? (&rest types)\n  `(progn\n     ,@(map (lambda (tt)\n              `(defun ,(intern (string-append tt \"?\")) (x)\n                 (eq? (type x) ',tt)))\n            types)))\n\n(deftype? symbol pair number string keyword vector table regexp)\n","\n;; Reverse list and concatenate tail destructively.\n(defun nreconc (ls tail)\n  (let1 top (reverse! ls)\n    (set-cdr! ls tail)\n    top))\n\n(defun any (f ls)\n  (cond ((null? ls) nil)\n        ((f (car ls)) t)\n        (t (any f (cdr ls)))))\n\n(defun every (f ls)\n  (cond ((null? ls) t)\n        ((f (car ls)) (every f (cdr ls)))\n        (t nil)))\n\n;;; http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node367.html\n\n;;; Common Lisp backquote implementation, written in Common Lisp.\n;;; Author: Guy L. Steele Jr.  Date: 27 December 1985\n;;; Tested under Symbolics Common Lisp and Lucid Common Lisp.\n;;; This software is in the public domain.\n\n;;; $ is pseudo-backquote and % is pseudo-comma. This makes it\n;;; possible to test this code without interfering with normal\n;;; Common Lisp syntax.\n\n;;; The following are unique tokens used during processing.\n;;; They need not be symbols; they need not even be atoms.\n\n(def *bq-clobberable* (gensym))\n(def *bq-quote-nil* (list 'quote ()))\n\n;;; Reader macro characters:\n;;;   $foo is read in as (BACKQUOTE foo)\n;;;   %foo is read in as (#:COMMA foo)\n;;;   %@foo is read in as (#:COMMA-ATSIGN foo)\n;;;   %.foo is read in as (#:COMMA-DOT foo)\n;;; where #:COMMA is the value of the variable *COMMA*, etc.\n\n;;; BACKQUOTE is an ordinary macro (not a read-macro) that\n;;; processes the expression foo, looking for occurrences of\n;;; #:COMMA, #:COMMA-ATSIGN, and #:COMMA-DOT. It constructs code\n;;; in strict accordance with the rules on pages 349-350 of\n;;; the first edition (pages 528-529 of this second edition).\n;;; It then optionally applies a code simplifier.\n\n;(set-macro-character #\\`\n;  (lambda (stream char)\n;     ;(declare (ignore char))\n;     (list 'quasiquote (read stream))))\n;\n;(set-macro-character #\\,\n;  (lambda (stream char)\n;     ;(declare (ignore char))\n;     (let1 c (read-char stream)\n;       (case c\n;         (#\\@\n;          (list 'unquote-splicing (read stream)))\n;         (#\\.\n;          (list 'unquote-dot (read stream)))\n;         (t (unread-char c stream)\n;            (list 'unquote (read stream)))))))\n\n;;; If the value of *BQ-SIMPLIFY* is non-NIL, then BACKQUOTE\n;;; processing applies the code simplifier. If the value is NIL,\n;;; then the code resulting from BACKQUOTE is exactly that\n;;; specified by the official rules.\n\n(defmacro quasiquote (x)\n  (bq-completely-process x))\n\n;;; Backquote processing proceeds in three stages:\n;;;\n;;; (1) BQ-PROCESS applies the rules to remove occurrences of\n;;; #:COMMA, #:COMMA-ATSIGN, and #:COMMA-DOT corresponding to\n;;; this level of BACKQUOTE. (It also causes embedded calls to\n;;; BACKQUOTE to be expanded so that nesting is properly handled.)\n;;; Code is produced that is expressed in terms of functions\n;;; #:BQ-LIST, #:BQ-APPEND, and #:BQ-CLOBBERABLE. This is done\n;;; so that the simplifier will simplify only list construction\n;;; functions actually generated by BACKQUOTE and will not involve\n;;; any user code in the simplification. #:BQ-LIST means LIST,\n;;; #:BQ-APPEND means APPEND, and #:BQ-CLOBBERABLE means IDENTITY\n;;; but indicates places where \"%.\" was used and where NCONC may\n;;; therefore be introduced by the simplifier for efficiency.\n;;;\n;;; (2) BQ-SIMPLIFY, if used, rewrites the code produced by\n;;; BQ-PROCESS to produce equivalent but faster code. The\n;;; additional functions #:BQ-LIST* and #:BQ-NCONC may be\n;;; introduced into the code.\n;;;\n;;; (3) BQ-REMOVE-TOKENS goes through the code and replaces\n;;; #:BQ-LIST with LIST, #:BQ-APPEND with APPEND, and so on.\n;;; #:BQ-CLOBBERABLE is simply eliminated (a call to it being\n;;; replaced by its argument). #:BQ-LIST* is replaced by either\n;;; LIST* or CONS (the latter is used in the two-argument case,\n;;; purely to make the resulting code a tad more readable).\n\n(defun bq-completely-process (x)\n  (bq-simplify (bq-process x)))\n\n(defun bq-process (x)\n  (cond ((not (pair? x))\n         (list 'quote x))\n        ((eq? (car x) 'quasiquote)\n         (bq-process (bq-completely-process (cadr x))))\n        ((eq? (car x) 'unquote) (cadr x))\n        ((eq? (car x) 'unquote-splicing)\n         (error \",@~S after `\" (cadr x)))\n        ((eq? (car x) 'unquote-dot)\n         (error \",.~S after `\" (cadr x)))\n        (t (let loop ((p x)\n                      (q ()))\n                (if (not (pair? p))\n                    (cons 'append\n                          (nreconc q (list (list 'quote p))))\n                  (if (eq? (car p) 'unquote)\n                      (progn (unless (null? (cddr p)) (error \"Malformed ,~S\" p))\n                             (cons 'append\n                                   (nreconc q (list (cadr p)))))\n                    (progn (when (eq? (car p) 'unquote-splicing)\n                             (error \"Dotted ,@~S\" p))\n                           (when (eq? (car p) 'unquote-dot)\n                             (error \"Dotted ,.~S\" p))\n                           (loop (cdr p)\n                                 (cons (bracket (car p)) q)))))))))\n\n;;; This implements the bracket operator of the formal rules.\n\n(defun bracket (x)\n  (cond ((not (pair? x))\n         (list 'list (bq-process x)))\n        ((eq? (car x) 'unquote)\n         (list 'list (cadr x)))\n        ((eq? (car x) 'unquote-splicing)\n         (cadr x))\n        ((eq? (car x) 'unquote-dot)\n         (list *bq-clobberable* (cadr x)))\n        (t (list 'list (bq-process x)))))\n\n;;; This auxiliary function is like MAPCAR but has two extra\n;;; purposes: (1) it handles dotted lists; (2) it tries to make\n;;; the result share with the argument x as much as possible.\n\n(defun maptree (fn x)\n  (if (not (pair? x))\n      (fn x)\n    (let ((a (fn (car x)))\n          (d (maptree fn (cdr x))))\n      (if (and (equal? a (car x)) (equal? d (cdr x)))\n          x\n        (cons a d)))))\n\n;;; This predicate is true of a form that when read looked\n;;; like %@foo or %.foo.\n\n(defun bq-splicing-frob (x)\n  (and (pair? x)\n       (or (eq? (car x) 'unquote-splicing)\n           (eq? (car x) 'unquote-dot))))\n\n;;; This predicate is true of a form that when read\n;;; loocked like %@foo or %.foo or just place %foo.\n\n(defun bq-frob (x)\n  (and (pair? x)\n       (or (eq? (car x) 'unquote)\n           (eq? (car x) 'unquote-splicing)\n           (eq? (car x) 'unquote-dot))))\n\n;;; The simplifier essentially looks for calls to #:BQ-APPEND and\n;;; tries to simplify them. The arguments to #:BQ-APPEND are\n;;; processed from right to left, building up a replacement form.\n;;; At each step a number of special cases are handled that,\n;;; loosely speaking, look like this:\n;;;\n;;; (APPEND (LIST a b c) foo) U> (LIST* a b c foo)\n;;;     provided a, b, c are not splicing frobs\n;;; (APPEND (LIST* a b c) foo) U> (LIST* a b (APPEND c foo))\n;;;     provided a, b, c are not splicing frobs\n;;; (APPEND (QUOTE (x)) foo) U> (LIST* (QUOTE x) foo)\n;;; (APPEND (CLOBBERABLE x) foo) U> (NCONC x foo)\n\n(defun bq-simplify (x)\n  (if (pair? x)\n      (let ((x (if (eq? (car x) 'quote)\n                   x\n                 (maptree bq-simplify x))))\n        (if (not (eq? (car x) 'append))\n            x\n          (bq-simplify-args x)))\n    x))\n\n(defun bq-simplify-args (x)\n  (let loop ((args (reverse (cdr x)))\n             (result ()))\n    (if (not (null? args))\n        (loop (cdr args)\n              (cond ((not (pair? (car args)))\n                     (bq-attach-append 'append (car args) result))\n                    ((and (eq? (caar args) 'list)\n                          (not (any bq-splicing-frob (cdar args))))\n                     (bq-attach-conses (cdar args) result))\n                    ((and (eq? (caar args) 'list*)\n                          (not (any bq-splicing-frob (cdar args))))\n                     (bq-attach-conses\n                      (reverse (cdr (reverse (cdar args))))\n                      (bq-attach-append 'append\n                                        (car (last (car args)))\n                                        result)))\n                    ((and (eq? (caar args) 'quote)\n                          (pair? (cadar args))\n                          (not (bq-frob (cadar args)))\n                          (not (cddar args)))\n                     (bq-attach-conses (list (list 'quote\n                                                   (caadar args)))\n                                       result))\n                    ((eq? (caar args) *bq-clobberable*)\n                     (bq-attach-append 'append! (cadar args) result))\n                    (t (bq-attach-append 'append\n                                         (car args)\n                                         result))))\n      result)))\n\n(defun null-or-quoted (x)\n  (or (null? x) (and (pair? x) (eq? (car x) 'quote))))\n\n;;; When BQ-ATTACH-APPEND is called, the OP should be #:BQ-APPEND\n;;; or #:BQ-NCONC. This produces a form (op item result) but\n;;; some simplifications are done on the fly:\n;;;\n;;; (op '(a b c) '(d e f g)) U> '(a b c d e f g)\n;;; (op item 'nil) U> item, provided item is not a splicable frob\n;;; (op item ’nil) U>(op item), if item is a splicable frob\n;;; (op item (op a b c)) U> (op item a b c)\n\n(defun bq-attach-append (op item result)\n  (cond ((and (null-or-quoted item) (null-or-quoted result))\n         (list 'quote (append (cadr item) (cadr result))))\n        ((or (null? result) (equal? result *bq-quote-nil*))\n         (if (bq-splicing-frob item) (list op item) item))\n        ((and (pair? result) (eq? (car result) op))\n         (list* (car result) item (cdr result)))\n        (t (list op item result))))\n\n;;; The effect of BQ-ATTACH-CONSES is to produce a form as if by\n;;; `(LIST* ,@items ,result) but some simplifications are done\n;;; on the fly.\n;;;\n;;; (LIST* 'a 'b 'c 'd) U> '(a b c . d)\n;;; (LIST* a b c 'nil) U> (LIST a b c)\n;;; (LIST* a b c (list* d e f g)) U> (LIST* a b c d e f g)\n;;; (LIST* a b c (list d e f g)) U> (LIST a b c d e f g)\n\n(defun bq-attach-conses (items result)\n  (cond ((and (every null-or-quoted items)\n              (null-or-quoted result))\n         (list 'quote\n               (append (map cadr items) (cadr result))))\n        ((or (null? result) (equal? result *bq-quote-nil*))\n         (cons 'list items))\n        ((and (pair? result)\n              (or (eq? (car result) 'list)\n                  (eq? (car result) 'list*)))\n         (cons (car result) (append items (cdr result))))\n        (t (cons 'list* (append items (list result))))))\n",";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; Scope\n\n(defun create-scope (parent-scope params)\n  (vector (remove-if (lambda (x) (member x '(&rest &body))) params)  ;; 0: params\n          nil             ; 1: added var (e.g. quoted values)\n          parent-scope))  ; 2: parent scope\n\n(defun scope-param (scope)\n  (vector-ref scope 0))\n\n(defun scope-outer (scope)\n  (vector-ref scope 2))\n\n(defun scope-add-var (scope val)\n  (let1 x (gensym)\n    (vector-set! scope 1\n                 (cons (cons x val) (vector-ref scope 1)))\n    (vector-set! scope 0\n                 (cons x (vector-ref scope 0)))\n    x))\n\n(defun scope-get-var (scope)\n  (vector-ref scope 1))\n\n(defun scope-var? (scope x)\n  (cond ((null? scope) nil)\n        ((member x (scope-param scope)) t)\n        (t (scope-var? (scope-outer scope) x))))\n\n(defun local-var? (scope sym)\n  (and (symbol? sym)\n       (scope-var? scope (get-receiver sym))))\n\n(defun special-var? (scope sym)\n  (member sym '(this)))\n\n;; Get symbol which sits on the top of dot-concatenated symbol.\n;;   ex. foo.bar.baz => foo\n(defun get-receiver (sym)\n  (let ((s (symbol->string sym)))\n    (aif (string-scan s \".\")\n         (intern (substring s 0 it))\n      sym)))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; Syntax Tree creator.\n(defmacro record (args param &body body)\n  `(apply (lambda ,param ,@body)\n          ,args))\n\n(defmacro record-case (x &body clauses)\n  (let1 value (gensym)\n    `(let1 ,value ,x\n       (case (car ,value)\n         ,@(map (lambda (clause)\n                  (if (eq? (car clause) t)\n                      clause\n                    (let1 key (caar clause)\n                      `((,key)\n                        (record (cdr ,value) ,(cdar clause) ,@(cdr clause))))))\n                clauses)))))\n\n(labels ((traverse-args (args scope)\n                        (map (lambda (x)\n                               (traverse* x scope))\n                             args))\n         (confirm-valid-params (params)\n                               (when params\n                                 (if (symbol? (car params))\n                                     (confirm-valid-params (cdr params))\n                                   (compile-error \"function parameter must be symbol, but\" (car params)))))\n         (traverse-quoted-value (x)\n                                (if (pair? x)\n                                    (vector :FUNCALL (vector :REF (if (proper-list? x) 'list 'list*))\n                                            (map traverse-quoted-value (dotted->proper x)))\n                                  (vector :CONST x))))\n\n  (defun traverse-list (s scope)\n    (record-case s\n                 ((quote x)   (cond ((pair? x)  (vector :REF (scope-add-var scope (traverse-quoted-value x))))\n                                    (t (vector :CONST x))))\n                 ((if p thn &body els)  (vector :IF\n                                                (traverse* p scope)\n                                                (traverse* thn scope)\n                                                (if (null? els)\n                                                    nil\n                                                  (traverse* (car els) scope))))\n                 ((set! x v)  (vector :SET! (traverse* x scope) (traverse* v scope)))\n                 ((lambda params &body body)  (progn (confirm-valid-params params)\n                                                     (let ((new-scope (create-scope scope params)))\n                                                       (vector :LAMBDA\n                                                               new-scope\n                                                               params\n                                                               (traverse-args body new-scope)))))\n                 ((def name value)  (vector :DEF\n                                            (traverse* name scope)\n                                            (traverse* value scope)))\n                 ((new klass &rest args)  (vector :NEW klass (traverse-args args new-scope)))\n                 (t (vector :FUNCALL\n                            (traverse* (car s) scope)\n                            (traverse-args (cdr s) scope))))))\n\n(defun traverse* (s scope)\n  (cond ((pair? s)   (if (local-var? scope (car s))\n                         ;; Symbol is defined in the scope, so it isn't handled as a macro.\n                         (traverse-list s scope)\n                       (let1 expanded (macroexpand s)\n                         (if (pair? expanded)\n                             (traverse-list expanded scope)\n                           (traverse* expanded scope)))))\n        ((symbol? s) (vector :REF s))\n        (t           (vector :CONST s))))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; Compiler\n\n(defun expand-args (args scope)\n  (string-join (map (lambda (x) (compile* x scope))\n                    args)\n               \", \"))\n\n(defun expand-body (body scope)\n  (if (null? body)\n      \"LISP.nil\"\n    (expand-args body scope)))\n\n(let1 table (make-hash-table)\n  (hash-table-put! table \"\\\\\" \"\\\\\\\\\")\n  (hash-table-put! table \"\\t\" \"\\\\t\")\n  (hash-table-put! table \"\\n\" \"\\\\n\")\n  (hash-table-put! table \"\\\"\" \"\\\\\\\"\")\n  (defun escape-char (c)\n    (or (hash-table-get table c)\n        c)))\n\n(defun escape-string (s)\n  (regexp-replace-all #/[\\\\\\t\\n\"]/ s  ;; \"\n                      (lambda (m) (escape-char (m)))))\n\n(defun escape-sym-char (c)\n  (string-append \"$\"\n                 (integer->hex-string (char->integer c) \"00\")))\n\n(defun integer->hex-string (x padding)\n  (let* ((s (string-append padding\n                           (number->string x 16)))\n         (sl (string-length s))\n         (pl (string-length padding)))\n    (substring s (- sl pl) sl)))\n\n(defun escape-symbol (sym)\n  (regexp-replace-all #/[^0-9A-Za-z_.]/ (symbol->string sym)\n                      (lambda (m) (escape-sym-char (string-ref (m) 0)))))\n\n(defun compile-symbol (sym scope)\n  (if (or (local-var? scope sym)\n          (special-var? scope sym))\n      (escape-symbol sym)\n    (let ((s (symbol->string sym)))\n      (if (rxmatch #/^[0-9A-Za-z_.]*$/ s)\n          (string-append \"LISP.\"\n                         s)\n        (string-append \"LISP[\\\"\"\n                       (escape-string s)\n                       \"\\\"]\")))))\n\n(defun compile-keyword (keyword)\n  (string-append \"LISP[\\\"make-keyword\\\"](\\\"\"\n                 (escape-string (keyword->string keyword))\n                 \"\\\")\"))\n\n(defun compile-vector (vect scope)\n  (string-append \"[\"\n                 (string-join (map (lambda (x) (compile-quote x scope))\n                                   (vector->list vect))\n                              \", \")\n                 \"]\"))\n\n(defun compile-regexp (regex)\n  (string-append \"/\"\n                 (regexp->string regex)\n                 \"/\"))\n\n(defun compile-literal (s scope)\n  (cond ((number? s)  (number->string s))\n        ((symbol? s)  (compile-symbol s scope))\n        ((keyword? s) (compile-keyword s))\n        ((string? s)  (x->string s t))\n        ((vector? s)  (compile-vector s scope))\n        ((regexp? s)  (compile-regexp s))\n        ((null? s)    \"LISP.nil\")\n        ((eq? s t)    \"LISP.t\")\n        (t (error (string-append \"compile-literal: [\" s \"]\")))))\n\n(defun unary-op? (sym)\n  (member sym '(+ - ! ~)))\n\n(defun compile-unary-op (fn arg scope)\n  (string-append \"(\"\n                 (symbol->string fn)\n                 (compile* arg scope)\n                 \")\"))\n\n(defun binop? (sym)\n  (member sym '(+ - * / %)))\n\n(defun compile-binop (fn args scope)\n  (string-append \"(\"\n                 (string-join (map (lambda (x) (compile* x scope))\n                                   args)\n                              (string-append \" \" (symbol->string fn) \" \"))\n                 \")\"))\n\n(defun do-compile-funcall (fn args scope)\n  (string-append (compile* fn scope)\n                 \"(\"\n                 (expand-args args scope)\n                 \")\"))\n\n(defun compile-funcall (fn args scope)\n  (if (and (eq? (vector-ref fn 0) :REF)\n           (not (local-var? scope (vector-ref fn 1)))\n           (not (null? args)))\n      (let1 fnsym (vector-ref fn 1)\n        (cond ((and (binop? fnsym)\n                    (not (null? (cdr args))))\n               (compile-binop fnsym args scope))\n              ((and (unary-op? fnsym)\n                    (null? (cdr args)))\n               (compile-unary-op fnsym (car args) scope))\n              (t (do-compile-funcall fn args scope))))\n    (do-compile-funcall fn args scope)))\n\n(defun compile-quote (x scope)\n  (cond ((pair? x)\n         (compile* `(cons ',(car x)\n                          ',(cdr x))\n                   scope))\n        ((symbol? x)\n         (string-append \"LISP.intern(\\\"\"\n                        (escape-string (symbol->string x))\n                        \"\\\")\"))\n        ((keyword? x)\n         (compile-keyword x))\n        (t (compile-literal x scope))))\n\n(defun compile-if (pred-node then-node else-node scope)\n  (string-append \"(LISP.isTrue(\"\n                 (compile* pred-node scope)\n                 \") ? (\"\n                 (compile* then-node scope)\n                 \") : (\"\n                 (if else-node\n                     (compile* else-node scope)\n                   \"LISP.nil\")\n                 \"))\"))\n\n(defun compile-set! (sym val scope)\n  (string-append (compile* sym scope)\n                 \" = \"\n                 (compile* val scope)))\n\n(defun compile-lambda (params bodies base-scope extended-scope)\n  (unless (or (null? params) (pair? params))\n    (error \"function parameters must be a list\"))\n  (let1 rest-pos (position-if (lambda (sym) (member sym '(&rest &body))) params)\n    (let ((proper-params (if rest-pos\n                             (take rest-pos params)\n                           params))\n          (rest (and rest-pos (elt (+ rest-pos 1) params))))\n      (string-append \"(function(\"\n                     (string-join (map (lambda (x) (escape-symbol x))\n                                       proper-params)\n                                  \", \")\n                     \"){\"\n                     (if (null? rest)\n                         \"\"\n                       (string-append \"var \"\n                                      (escape-symbol rest)\n                                      \" = LISP._getRestArgs(arguments, \"\n                                      (number->string (length proper-params))\n                                      \"); \"))\n                     \"return (\"\n                     (expand-body bodies extended-scope)\n                     \");})\"))))\n\n(defun compile-def (name value scope)\n  (string-append (compile* name scope)\n                 \" = \"\n                 (compile* value scope)))\n\n(defun compile-new (class-name args scope)\n  (string-append \"new \"\n                 (symbol->string class-name)\n                 \"(\"\n                 (expand-args args scope)\n                 \")\"))\n\n;; If the given scope has quoted value, output them as local variable values,\n;; and encapsulate with anonymous function.\n(defun compile-new-scope (compiled-body scope)\n  (aif (scope-get-var scope)\n       (string-append \"(function() { var \"\n                      (string-join (map (lambda (x)\n                                          (string-append (escape-symbol (car x))\n                                                         \" = \"\n                                                         (compile* (cdr x) scope)))\n                                        (reverse it))\n                                   \", \")\n                      \"; return \"\n                      compiled-body\n                      \"; })()\")\n    compiled-body))\n\n(defun compile* (s scope)\n  (case (vector-ref s 0)\n    ((:CONST)  (compile-quote (vector-ref s 1) scope))\n    ((:REF)    (compile-symbol (vector-ref s 1) scope))\n    ((:IF)     (let ((p (vector-ref s 1))\n                     (thn (vector-ref s 2))\n                     (els (vector-ref s 3)))\n                 (compile-if p thn els scope)))\n    ((:FUNCALL)  (compile-funcall (vector-ref s 1) (vector-ref s 2) scope))\n    ((:SET!)  (compile-set! (vector-ref s 1) (vector-ref s 2) scope))\n    ((:LAMBDA)  (let ((extended-scope (vector-ref s 1))\n                      (params (vector-ref s 2))\n                      (body (vector-ref s 3)))\n                  (compile-new-scope (compile-lambda params body scope extended-scope)\n                                     extended-scope)))\n    ((:DEF)  (compile-def (vector-ref s 1) (vector-ref s 2) scope))\n    ((:NEW)  (compile-new (vector-ref s 1) (vector-ref s 2) scope))\n    (t  (compile-error \"Unknown AST node:\" s))))\n\n(defun compile-error (&rest args)\n  (error args))\n\n(defun compile (s)\n  (let* ((top-scope (create-scope nil ()))\n         (tree (traverse* s top-scope)))\n    ;;(write tree)\n    (compile-new-scope (compile* tree top-scope)\n                       top-scope)))\n"],"sourceRoot":"/source/"}