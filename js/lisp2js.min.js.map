{"version":3,"sources":["lisp2js.js","/source/runtime.js"],"names":["_typeof2","obj","Symbol","constructor","_possibleConstructorReturn","self","call","ReferenceError","_inherits","subClass","superClass","TypeError","prototype","Object","create","value","enumerable","writable","configurable","setPrototypeOf","__proto__","_typeof","_classCallCheck","instance","Constructor","_createClass","defineProperties","target","props","i","length","descriptor","defineProperty","key","protoProps","staticProps","createLisp","installEval","g","window","GLOBAL","LISP","module","exports","global","arrayToList","array","result","nil","cons","jsBoolToS","x","t","arguments2Array","args","start","len","Array","makeString","inspect","inspectString","map","v","join","toString","isTrue","_getRestArgs","slice","_output","process","str","stdout","write","console","log","macroTable","name","func","s","car","macrofn","apply","cdr","error","arguments","this","intern","symbolTable","gensym","index","Keyword","keywordTable","type","undefined","Cons","HashTable","y","abbrevTable","quote","quasiquote","unquote","unquote-splicing","lineNo","path","ss","separator","p","push","list","rev","ls","d","n","toArray","substring","end","item","indexOf","char","charCodeAt","kEscapeCharTable","\\","\t","\n","\"","f","m","replace","print","puts","fn","params","last","concat","JS","contents","k","hasOwnProperty","hash","vector","count","RegExp","rxmatch","re","exec","lastIndexOf","match","Stream","fetch","c","peek","regexp","keep","rightContext","readLine","StrStream","_Stream","_this","getPrototypeOf","NoCloseParenException","kDelimitors","kReSingleDot","kReSymbolOrNumber","kReadUnescapeTable","readTable","Reader","stream","eof","getc","readList","read","unescape","readVector","readSymbolOrNumber","parseFloat","reversed","_1","_2","hex","String","fromCharCode","parseInt","c2","keyword","getLine","fs","require","BUFFER_SIZE","buffer","Buffer","FileStream","_Stream2","fd","_this2","lines","closeSync","chomped","left","readSync","string","split","stdin","stderr","open","flag","openSync","e","close","load","fileName","eval","exit","code","jsrequire","body","pairs","__2","cadr","caar","cadar","pred","clauses","clause","rest","caddr","cdar","__3","expr","thn","els","loop","append","not","cddr","cdddr","xtype","__4","__5","acc","member","assoc","acons","datum","alist","reverse","q","dot","dup","vect","seq","take","__6","drop","__7","elt","test","__8","__9","limit","pair","lss","nreconc","tail","top","any","every","bracket","maptree","a","cddar","caadar","op","items","macroexpand","exp","expanded","parent$2dscope","scope","val","sym","it","param","traverse$2dargs","confirm$2dvalid$2dparams","traverse$2dquoted$2dvalue","new$2dscope","klass","table","padding","sl","pl","regex","arg","fnsym","pred$2dnode","then$2dnode","else$2dnode","bodies","base$2dscope","extended$2dscope","rest$2dpos","proper$2dparams","class$2dname","compiled$2dbody","__10","compile","top$2dscope","tree"],"mappings":"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","file":"lisp2js.min.js","sourcesContent":["'use strict';\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _typeof(obj) { return obj && typeof Symbol !== \"undefined\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n(function (createLisp, installEval) {\n  'use strict';\n\n  var g = typeof window !== 'undefined' ? window : typeof GLOBAL !== 'undefined' ? GLOBAL : {};\n\n  var LISP = createLisp(g);\n  installEval(LISP);\n\n  if (typeof module !== 'undefined') module.exports = LISP;else g.LISP = LISP;\n})(function (global) {\n  'use strict';\n\n  var LISP = {};\n\n  // Convert JS array into Lisp list.\n  var arrayToList = function arrayToList(array) {\n    var result = LISP.nil;\n    for (var i = array.length; --i >= 0;) {\n      result = LISP.cons(array[i], result);\n    }return result;\n  };\n\n  var jsBoolToS = function jsBoolToS(x) {\n    return x ? LISP.t : LISP.nil;\n  };\n  var arguments2Array = function arguments2Array(args, start) {\n    var len = args.length - start;\n    if (len <= 0) return [];\n    var array = new Array(len);\n    for (var i = 0; i < len; ++i) {\n      array[i] = args[i + start];\n    }return array;\n  };\n\n  var makeString = function makeString(x, inspect) {\n    if (x === LISP.nil) return 'nil';\n    if (x === LISP.t) return 't';\n    if (typeof x == 'string') return inspect ? inspectString(x) : x;\n    if (x instanceof Array) return '#(' + x.map(function (v) {\n      return makeString(v, inspect);\n    }).join(' ') + ')';\n    if (x == null) // null or undefined\n      return '' + x;\n    return x.toString(inspect);\n  };\n\n  LISP.nil = false;\n  LISP.t = true;\n\n  LISP.isTrue = function (x) {\n    return x !== LISP.nil && x != null; // !(false || null || undefined)\n  };\n\n  LISP._getRestArgs = function (args, start) {\n    return arrayToList(Array.prototype.slice.call(args, start));\n  };\n  LISP._output = typeof process !== 'undefined' ? function (str) {\n    // for node.js.\n    process.stdout.write(str);\n  } : function (str) {\n    // for browser.\n    console.log(str);\n  };\n\n  var macroTable = {};\n  LISP['register-macro'] = function (name, func) {\n    macroTable[name] = func;\n    return name;\n  };\n  LISP['macroexpand-1'] = function (s) {\n    if (!LISP['pair?'](s) || !(s.car in macroTable)) return s;\n    var macrofn = macroTable[s.car];\n    return LISP.apply(macrofn, s.cdr);\n  };\n\n  LISP.error = function () {\n    throw arguments2Array(arguments, 0).join(', ');\n  };\n\n  // Symbol.\n\n  var Symbol = (function () {\n    function Symbol(name) {\n      _classCallCheck(this, Symbol);\n\n      this.name = name;\n    }\n\n    _createClass(Symbol, [{\n      key: 'toString',\n      value: function toString() {\n        return this.name;\n      }\n    }]);\n\n    return Symbol;\n  })();\n\n  LISP['symbol->string'] = function (x) {\n    return x.name;\n  };\n\n  LISP.intern = (function () {\n    var symbolTable = {}; // key(string) => Symbol object\n    return function (name) {\n      if (name in symbolTable) return symbolTable[name];\n      return symbolTable[name] = new Symbol(name);\n    };\n  })();\n  LISP.gensym = (function () {\n    var index = 0;\n    return function () {\n      return LISP.intern('__' + ++index);\n    };\n  })();\n  LISP['symbol?'] = function (x) {\n    return jsBoolToS(x instanceof Symbol);\n  };\n\n  var Keyword = (function () {\n    function Keyword(name) {\n      _classCallCheck(this, Keyword);\n\n      this.name = name;\n    }\n\n    _createClass(Keyword, [{\n      key: 'toString',\n      value: function toString(inspect) {\n        return inspect ? ':' + this.name : this.name;\n      }\n    }]);\n\n    return Keyword;\n  })();\n\n  LISP['make-keyword'] = (function () {\n    var keywordTable = {}; // key(string) => Keyword object\n    return function (name) {\n      if (name in keywordTable) return keywordTable[name];\n      return keywordTable[name] = new Keyword(name);\n    };\n  })();\n  LISP['keyword?'] = function (x) {\n    return jsBoolToS(x instanceof Keyword);\n  };\n  LISP['keyword->string'] = function (x) {\n    return x.name;\n  };\n\n  LISP.type = function (x) {\n    var type = undefined;\n    if (x === LISP.nil || x === LISP.t) type = 'bool';else {\n      type = typeof x === 'undefined' ? 'undefined' : _typeof(x);\n      if (type === 'object') {\n        if (x instanceof Symbol) type = 'symbol';else if (x instanceof Keyword) type = 'keyword';else if (x instanceof Cons) type = 'pair';else if (x instanceof Array) type = 'vector';else if (x instanceof HashTable) type = 'table';\n      }\n    }\n    return LISP.intern(type);\n  };\n\n  LISP['eq?'] = function (x, y) {\n    return jsBoolToS(x === y);\n  };\n\n  // Cons cell.\n  var abbrevTable = { quote: '\\'', quasiquote: '`', unquote: ',', 'unquote-splicing': ',@' };\n\n  var Cons = (function () {\n    function Cons(car, cdr, lineNo, path) {\n      _classCallCheck(this, Cons);\n\n      this.car = car;\n      this.cdr = cdr;\n\n      if (lineNo != null) {\n        this.lineNo = lineNo;\n        this.path = path;\n      }\n    }\n\n    _createClass(Cons, [{\n      key: 'toString',\n      value: function toString(inspect) {\n        if (this.car instanceof Symbol && // (symbol? car)\n        this.cdr instanceof Cons && // (pair? cdr)\n        this.cdr.cdr && // (null? (cdr cdr))\n        this.car.name in abbrevTable) {\n          return abbrevTable[this.car.name] + makeString(this.cdr.car, inspect);\n        }\n\n        var ss = [];\n        var separator = '(';\n        var p = undefined;\n        for (p = this; p instanceof Cons; p = p.cdr) {\n          ss.push(separator);\n          ss.push(makeString(p.car, inspect));\n          separator = ' ';\n        }\n        if (p !== LISP.nil) {\n          ss.push(' . ');\n          ss.push(makeString(p, inspect));\n        }\n        ss.push(')');\n        return ss.join('');\n      }\n    }, {\n      key: 'toArray',\n      value: function toArray() {\n        var result = [];\n        for (var p = this; p instanceof Cons; p = p.cdr) {\n          result.push(p.car);\n        }return result;\n      }\n    }]);\n\n    return Cons;\n  })();\n\n  LISP.cons = function (car, cdr) {\n    return new Cons(car, cdr);\n  };\n  LISP.car = function (s) {\n    if (s instanceof Cons) return s.car;\n    return s;\n  };\n  LISP.cdr = function (s) {\n    if (s instanceof Cons) return s.cdr;\n    return LISP.nil;\n  };\n  LISP['set-car!'] = function (s, x) {\n    return s.car = x;\n  };\n  LISP['set-cdr!'] = function (s, x) {\n    return s.cdr = x;\n  };\n\n  LISP['pair?'] = function (x) {\n    return jsBoolToS(x instanceof Cons);\n  };\n  LISP.list = function () {\n    var result = LISP.nil;\n    for (var i = arguments.length; --i >= 0;) {\n      result = LISP.cons(arguments[i], result);\n    }return result;\n  };\n  LISP['reverse!'] = function (x) {\n    var rev = LISP.nil;\n    for (var ls = x; LISP['pair?'](ls);) {\n      var d = ls.cdr;\n      ls.cdr = rev;\n      rev = ls;\n      ls = d;\n    }\n    return rev;\n  };\n\n  LISP['number?'] = function (x) {\n    return jsBoolToS(typeof x === 'number');\n  };\n  LISP['number->string'] = function (x, n) {\n    return x.toString(n);\n  };\n  LISP['+'] = function () {\n    if (arguments.length == 0) return 0;\n    var result = arguments[0];\n    for (var i = 1; i < arguments.length; ++i) {\n      result += arguments[i];\n    }return result;\n  };\n  LISP['*'] = function () {\n    if (arguments.length == 0) return 1;\n    var result = arguments[0];\n    for (var i = 1; i < arguments.length; ++i) {\n      result *= arguments[i];\n    }return result;\n  };\n  LISP['-'] = function () {\n    if (arguments.length == 0) return 0;\n    var result = arguments[0];\n    if (arguments.length == 1) return -result;\n    for (var i = 1; i < arguments.length; ++i) {\n      result -= arguments[i];\n    }return result;\n  };\n  LISP['/'] = function () {\n    if (arguments.length == 0) return 1;\n    var result = arguments[0];\n    if (arguments.length == 1) return 1.0 / result;\n    for (var i = 1; i < arguments.length; ++i) {\n      result /= arguments[i];\n    }return result;\n  };\n  LISP['%'] = function () {\n    if (arguments.length == 0) return 0;\n    var result = arguments[0];\n    if (arguments.length == 1) return result;\n    for (var i = 1; i < arguments.length; ++i) {\n      result %= arguments[i];\n    }return result;\n  };\n  LISP['<'] = function () {\n    if (arguments.length > 0) {\n      var value = arguments[0];\n      for (var i = 1; i < arguments.length; ++i) {\n        var target = arguments[i];\n        if (!(value < target)) return LISP.nil;\n        value = target;\n      }\n    }\n    return LISP.t;\n  };\n  LISP['>'] = function () {\n    if (arguments.length > 0) {\n      var value = arguments[0];\n      for (var i = 1; i < arguments.length; ++i) {\n        var target = arguments[i];\n        if (!(value > target)) return LISP.nil;\n        value = target;\n      }\n    }\n    return LISP.t;\n  };\n  LISP['<='] = function () {\n    if (arguments.length > 0) {\n      var value = arguments[0];\n      for (var i = 1; i < arguments.length; ++i) {\n        var target = arguments[i];\n        if (!(value <= target)) return LISP.nil;\n        value = target;\n      }\n    }\n    return LISP.t;\n  };\n  LISP['>='] = function () {\n    if (arguments.length > 0) {\n      var value = arguments[0];\n      for (var i = 1; i < arguments.length; ++i) {\n        var target = arguments[i];\n        if (!(value >= target)) return LISP.nil;\n        value = target;\n      }\n    }\n    return LISP.t;\n  };\n\n  // String.\n  LISP['string?'] = function (x) {\n    return jsBoolToS(typeof x === 'string');\n  };\n  LISP['string=?'] = function (x, y) {\n    return jsBoolToS(x === y);\n  };\n  LISP['string-append'] = function () {\n    return arguments2Array(arguments, 0).join('');\n  };\n  LISP['string-join'] = function (list, separator) {\n    if (list === LISP.nil) return '';\n    return list.toArray().join(separator);\n  };\n  LISP['string-length'] = function (str) {\n    return str.length;\n  };\n  LISP['string-ref'] = function (str, index) {\n    return str[index];\n  };\n  LISP.substring = function (str, start, end) {\n    return str.slice(start, end);\n  };\n  LISP['string-scan'] = function (str, item) {\n    var index = str.indexOf(item);\n    return index >= 0 ? index : LISP.nil;\n  };\n\n  LISP['char->integer'] = function (char, index) {\n    return char.charCodeAt(index);\n  };\n\n  var kEscapeCharTable = { '\\\\': '\\\\\\\\', '\\t': '\\\\t', '\\n': '\\\\n', '\"': '\\\\\"' };\n  var inspectString = function inspectString(str) {\n    var f = function f(m) {\n      if (m in kEscapeCharTable) return kEscapeCharTable[m];\n      return '\\\\x' + ('0' + m.charCodeAt(0).toString(16)).slice(-2);\n    };\n    return '\"' + str.replace(/[\\x00-\\x1f\"\\\\]/g, f) + '\"';\n  };\n\n  LISP['x->string'] = makeString;\n  LISP.print = function (x) {\n    LISP._output(makeString(x));\n    return x;\n  };\n  LISP.puts = function (x) {\n    LISP._output(makeString(x));\n    if (typeof process !== 'undefined') LISP._output('\\n');\n    return x;\n  };\n  LISP.write = function (x) {\n    LISP._output(makeString(x, 10)); // 10 means true, and it is used as radix.\n    return x;\n  };\n\n  LISP.apply = function (fn) {\n    var params = [];\n    if (arguments.length > 1) {\n      for (var i = 1; i < arguments.length - 1; ++i) {\n        params.push(arguments[i]);\n      } // Last argument for `apply` is expected as list (or nil).\n      var last = arguments[arguments.length - 1];\n      if (last !== LISP.nil) params = params.concat(last.toArray());\n    }\n    return fn.apply(null, params);\n  };\n  LISP.JS = global;\n\n  var HashTable = (function () {\n    function HashTable() {\n      _classCallCheck(this, HashTable);\n    }\n\n    _createClass(HashTable, [{\n      key: 'toString',\n      value: function toString() {\n        var contents = '';\n        for (var k in this) {\n          if (!this.hasOwnProperty(k)) continue;\n          if (contents.length > 0) contents += ', ';\n          contents += k + ':' + this[k];\n        }\n        return '#table<' + contents + '>';\n      }\n    }]);\n\n    return HashTable;\n  })();\n\n  LISP.HashTable = HashTable;\n\n  // Hash table.\n  LISP['make-hash-table'] = function () {\n    return new HashTable();\n  };\n  LISP['hash-table?'] = function (x) {\n    return x instanceof HashTable;\n  };\n  LISP['hash-table-exists?'] = function (hash, x) {\n    return x in hash ? LISP.t : LISP.nil;\n  };\n  LISP['hash-table-get'] = function (hash, x) {\n    if (x in hash) return hash[x];\n    return arguments.length >= 3 ? arguments[3 - 1] : LISP.nil;\n  };\n  LISP['hash-table-put!'] = function (hash, x, value) {\n    return hash[x] = value;\n  };\n\n  // Vector.\n  LISP.vector = function () {\n    return arguments2Array(arguments, 0);\n  };\n  LISP['make-vector'] = function (count, value) {\n    if (value === undefined) value = LISP.nil;\n    var vector = new Array(count);\n    for (var i = 0; i < count; ++i) {\n      vector[i] = value;\n    }return vector;\n  };\n  LISP['vector?'] = function (x) {\n    return jsBoolToS(x instanceof Array);\n  };\n  LISP['vector-length'] = function (vector) {\n    return vector.length;\n  };\n  LISP['vector-ref'] = function (vector, index) {\n    return vector[index];\n  };\n  LISP['vector-set!'] = function (vector, index, value) {\n    return vector[index] = value;\n  };\n\n  // Regexp.\n  LISP['regexp?'] = function (x) {\n    return jsBoolToS(x instanceof RegExp);\n  };\n  LISP.rxmatch = function (re, str) {\n    return jsBoolToS(re.exec(str));\n  };\n  LISP['regexp-replace-all'] = function (re, str, fn) {\n    if (!re.global) {\n      var s = re.toString();\n      var i = s.lastIndexOf('/');\n      re = new RegExp(s.slice(1, i), s.slice(i + 1) + 'g');\n    }\n    return str.replace(re, function (match) {\n      return fn(function () {\n        // TODO: handle arguments.\n        return match;\n      });\n    });\n  };\n  LISP['regexp->string'] = function (x) {\n    var s = x.toString();\n    return s.slice(1, s.length - 1);\n  };\n\n  // Stream.\n\n  var Stream = (function () {\n    function Stream() {\n      _classCallCheck(this, Stream);\n\n      this.str = '';\n      this.lineNo = 0;\n    }\n\n    _createClass(Stream, [{\n      key: 'close',\n      value: function close() {}\n    }, {\n      key: 'peek',\n      value: function peek() {\n        var result = this.fetch();\n        if (result == null) return result;\n        return this.str[0];\n      }\n    }, {\n      key: 'getc',\n      value: function getc() {\n        var c = this.peek();\n        if (c == null) return c;\n        this.str = this.str.slice(1);\n        return c;\n      }\n    }, {\n      key: 'match',\n      value: function match(regexp, keep) {\n        var result = this.fetch();\n        if (result == null) return result;\n\n        var m = this.str.match(regexp);\n        if (m && !keep) this.str = RegExp.rightContext;\n        return m;\n      }\n    }, {\n      key: 'eof',\n      value: function eof() {\n        return this.str == null;\n      }\n    }, {\n      key: 'getLine',\n      value: function getLine() {\n        var result = this.str || this.readLine();\n        this.str = '';\n        return result;\n      }\n    }, {\n      key: 'fetch',\n      value: function fetch() {\n        if (this.str == null) return null;\n\n        if (this.str === '') {\n          if ((this.str = this.readLine()) == null) return undefined;\n          ++this.lineNo;\n        }\n        return this.str;\n      }\n    }]);\n\n    return Stream;\n  })();\n\n  var StrStream = (function (_Stream) {\n    _inherits(StrStream, _Stream);\n\n    function StrStream(str) {\n      _classCallCheck(this, StrStream);\n\n      var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(StrStream).call(this));\n\n      _this.str = str;\n      _this.lineNo = 1;\n      return _this;\n    }\n\n    _createClass(StrStream, [{\n      key: 'readLine',\n      value: function readLine() {\n        return null;\n      }\n    }]);\n\n    return StrStream;\n  })(Stream);\n\n  LISP.StrStream = StrStream;\n\n  // Reader.\n  LISP.NoCloseParenException = function () {};\n\n  var kDelimitors = '\\\\s(){}\\\\[\\\\]\\'`,;#\"';\n  var kReSingleDot = RegExp('^\\\\.(?=[' + kDelimitors + '])');\n  var kReSymbolOrNumber = RegExp('^([^' + kDelimitors + ']+)');\n  var kReadUnescapeTable = {\n    't': '\\t',\n    'n': '\\n'\n  };\n\n  var readTable = {};\n\n  var Reader = (function () {\n    function Reader() {\n      _classCallCheck(this, Reader);\n    }\n\n    _createClass(Reader, null, [{\n      key: 'read',\n      value: function read(stream) {\n        do {\n          if (stream.eof()) return null;\n        } while (stream.match(/^\\s+/));\n\n        var c = stream.peek();\n        if (c in readTable) return readTable[c](stream, stream.getc());\n\n        var m = undefined;\n        if (stream.match(/^\\(/)) // Left paren '('.\n          return Reader.readList(stream);\n        if (stream.match(/^;[^\\n]*\\n?/)) // Line comment.\n          return Reader.read(stream);\n        if (m = stream.match(/^\"((\\\\.|[^\"\\\\])*)\"/)) // string.\n          return Reader.unescape(m[1]);\n        if (stream.match(/^#\\(/)) // vector.\n          return Reader.readVector(stream);\n        if (m = stream.match(/^#\\/([^\\/]*)\\//)) // regexp TODO: Implement properly.\n          return new RegExp(m[1]);\n        if (stream.match(/^#\\|(.|[\\n\\r])*?\\|#/)) // Block comment.\n          return Reader.read(stream);\n        if (stream.match(kReSingleDot, true)) // Single dot.\n          return undefined;\n        if (m = stream.match(kReSymbolOrNumber)) // Symbol or number.\n          return Reader.readSymbolOrNumber(m[1]);\n        return undefined;\n      }\n    }, {\n      key: 'readSymbolOrNumber',\n      value: function readSymbolOrNumber(str) {\n        if (str === 'nil') return LISP.nil;\n        if (str === 't') return LISP.t;\n        if (str[0] === ':') return LISP['make-keyword'](str.slice(1));\n        if (str.match(/^([+\\-]?[0-9]+(\\.[0-9]*)?)$/)) // Number.\n          return parseFloat(str);\n        return LISP.intern(str);\n      }\n    }, {\n      key: 'readList',\n      value: function readList(stream) {\n        var result = LISP.nil;\n        for (;;) {\n          var x = Reader.read(stream);\n          if (x == null) break;\n          result = new Cons(x, result, stream.lineNo, stream.path);\n        }\n\n        if (stream.match(/^\\s*\\)/)) {\n          // Close paren.\n          return LISP['reverse!'](result);\n        }\n        if (stream.match(kReSingleDot)) {\n          // Dot.\n          var last = Reader.read(stream);\n          if (last != null) {\n            if (stream.match(/^\\s*\\)/)) {\n              // Close paren.\n              var reversed = LISP['reverse!'](result);\n              result.cdr = last;\n              return reversed;\n            }\n          }\n        }\n        // Error\n        throw new LISP.NoCloseParenException();\n      }\n    }, {\n      key: 'readVector',\n      value: function readVector(stream) {\n        var result = [];\n        for (;;) {\n          var x = Reader.read(stream);\n          if (x !== undefined) {\n            result.push(x);\n            continue;\n          }\n\n          if (stream.match(/^\\s*\\)/)) {\n            // Close paren.\n            return result;\n          }\n          // Error\n          throw new LISP.NoCloseParenException();\n        }\n      }\n    }, {\n      key: 'unescape',\n      value: function unescape(str) {\n        return str.replace(/\\\\(x([0-9a-fA-F]{2})|(.))/g, function (_1, _2, hex, c) {\n          if (hex) return String.fromCharCode(parseInt(hex, 16));\n          if (c in kReadUnescapeTable) return kReadUnescapeTable[c];\n          return c;\n        });\n      }\n    }]);\n\n    return Reader;\n  })();\n\n  LISP['set-macro-character'] = function (c, fn) {\n    readTable[c] = fn;\n  };\n\n  LISP['set-macro-character']('\\'', function (stream, c) {\n    return LISP.list(LISP.intern('quote'), Reader.read(stream));\n  });\n  LISP['set-macro-character']('`', function (stream, c) {\n    return LISP.list(LISP.intern('quasiquote'), Reader.read(stream));\n  });\n  LISP['set-macro-character'](',', function (stream, c) {\n    var c2 = stream.peek();\n    var keyword = 'unquote';\n    if (c2 == '@') {\n      keyword = 'unquote-splicing';\n      stream.getc();\n    }\n    return LISP.list(LISP.intern(keyword), Reader.read(stream));\n  });\n\n  LISP.read = function (stream) {\n    return Reader.read(stream || LISP['*stdin*']);\n  };\n\n  LISP['read-from-string'] = function (str) {\n    return Reader.read(new StrStream(str));\n  };\n\n  LISP['read-line'] = function (stream) {\n    return (stream || LISP['*stdin*']).getLine();\n  };\n\n  // For node JS.\n  if (typeof process !== 'undefined') {\n    (function () {\n      var fs = require('fs');\n\n      var BUFFER_SIZE = 4096;\n      var buffer = new Buffer(BUFFER_SIZE);\n\n      var FileStream = (function (_Stream2) {\n        _inherits(FileStream, _Stream2);\n\n        function FileStream(fd, path) {\n          _classCallCheck(this, FileStream);\n\n          var _this2 = _possibleConstructorReturn(this, Object.getPrototypeOf(FileStream).call(this));\n\n          _this2.fd = fd;\n          _this2.path = path;\n          _this2.lines = [];\n          _this2.index = 0;\n          return _this2;\n        }\n\n        _createClass(FileStream, [{\n          key: 'close',\n          value: function close() {\n            if (this.fd == null) return;\n            fs.closeSync(this.fd);\n            this.fd = null;\n            this.lines.length = this.index = 0;\n            this.str = null;\n            this.chomped = false;\n          }\n        }, {\n          key: 'readLine',\n          value: function readLine() {\n            for (;;) {\n              var left = '';\n              if (this.index < this.lines.length) {\n                if (this.index < this.lines.length - 1 || !this.chomped) return this.lines[this.index++];\n                if (this.chomped) left = this.lines[this.index];\n              }\n\n              if (this.fd == null) return LISP.nil;\n              var n = fs.readSync(this.fd, buffer, 0, BUFFER_SIZE);\n              if (n <= 0) return null;\n              var string = left + buffer.slice(0, n).toString();\n              this.chomped = false;\n              if (string.length > 0) {\n                if (string[string.length - 1] != '\\n') this.chomped = true;else\n                  // Remove last '\\n' to avoid last empty line.\n                  string = string.slice(0, string.length - 1);\n              }\n              this.lines = string.split('\\n');\n              this.index = 0;\n            }\n          }\n        }]);\n\n        return FileStream;\n      })(Stream);\n\n      LISP.FileStream = FileStream;\n\n      LISP['*stdin*'] = new LISP.FileStream(process.stdin.fd, '*stdin*');\n      LISP['*stdout*'] = new LISP.FileStream(process.stdout.fd, '*stdout*');\n      LISP['*stderr*'] = new LISP.FileStream(process.stderr.fd, '*stderr*');\n\n      LISP.open = function (path, flag) {\n        try {\n          var fd = fs.openSync(path, flag || 'r');\n          return new LISP.FileStream(fd, path);\n        } catch (e) {\n          return LISP.nil;\n        }\n      };\n\n      LISP.close = function (stream) {\n        stream.close();\n        return stream;\n      };\n\n      LISP.load = function (fileName) {\n        var stream = LISP.open(fileName);\n        if (!stream) {\n          return LISP.error('Cannot open [' + fileName + ']');\n        }\n\n        if (stream.match(/^#!/, true)) stream.getLine(); // Skip Shebang.\n\n        var result = undefined;\n        for (;;) {\n          var s = LISP.read(stream);\n          if (s == null) break;\n          result = LISP.eval(s);\n        }\n        LISP.close(stream);\n        return result;\n      };\n\n      // System\n      LISP.exit = function (code) {\n        return process.exit(code);\n      };\n\n      LISP.jsrequire = require;\n    })();\n  }\n\n  /*==== EMBED COMPILED CODE HERE ====*/\n  LISP[\"register-macro\"](LISP.intern(\"defmacro\"), function (name, params) {\n    var body = LISP._getRestArgs(arguments, 2);return LISP.list(LISP.intern(\"register-macro\"), LISP.list(LISP.intern(\"quote\"), name), LISP[\"list*\"](LISP.intern(\"lambda\"), params, body));\n  });\n  LISP[\"register-macro\"](LISP.intern(\"defun\"), function (name, params) {\n    var body = LISP._getRestArgs(arguments, 2);return LISP.list(LISP.intern(\"def\"), name, LISP[\"list*\"](LISP.intern(\"lambda\"), params, body));\n  });\n  LISP[\"register-macro\"](LISP.intern(\"let\"), function (pairs) {\n    var body = LISP._getRestArgs(arguments, 1);return LISP.isTrue(LISP[\"symbol?\"](pairs)) ? (function () {\n      var __2 = LISP.list(LISP.nil);return function (name, pairs, body) {\n        return LISP[\"list*\"](LISP.list(LISP.intern(\"lambda\"), LISP.list(name), LISP.list(LISP.intern(\"set!\"), name, LISP[\"list*\"](LISP.intern(\"lambda\"), LISP.map(LISP.car, pairs), body)), LISP[\"list*\"](name, LISP.map(LISP.cadr, pairs))), __2);\n      };\n    })()(pairs, LISP.car(body), LISP.cdr(body)) : LISP[\"list*\"](LISP[\"list*\"](LISP.intern(\"lambda\"), LISP.map(LISP.car, pairs), body), LISP.map(LISP.cadr, pairs));\n  });\n  LISP[\"register-macro\"](LISP.intern(\"let1\"), function (name, value) {\n    var body = LISP._getRestArgs(arguments, 2);return LISP[\"list*\"](LISP.intern(\"let\"), LISP.list(LISP.list(name, value)), body);\n  });\n  LISP[\"register-macro\"](LISP.intern(\"let*\"), function (pairs) {\n    var body = LISP._getRestArgs(arguments, 1);return LISP.isTrue(LISP[\"null?\"](pairs)) ? LISP[\"list*\"](LISP.intern(\"do\"), body) : LISP.list(LISP.intern(\"let1\"), LISP.caar(pairs), LISP.cadar(pairs), LISP[\"list*\"](LISP.intern(\"let*\"), LISP.cdr(pairs), body));\n  });\n  LISP[\"register-macro\"](LISP.intern(\"when\"), function (pred) {\n    var body = LISP._getRestArgs(arguments, 1);return LISP.list(LISP.intern(\"if\"), pred, LISP[\"list*\"](LISP.intern(\"do\"), body));\n  });\n  LISP[\"register-macro\"](LISP.intern(\"unless\"), function (pred) {\n    var body = LISP._getRestArgs(arguments, 1);return LISP.list(LISP.intern(\"if\"), pred, LISP.nil, LISP[\"list*\"](LISP.intern(\"do\"), body));\n  });\n  LISP[\"register-macro\"](LISP.intern(\"cond\"), function () {\n    var clauses = LISP._getRestArgs(arguments, 0);return LISP.isTrue(LISP[\"null?\"](clauses)) ? LISP.nil : (function (clause, rest) {\n      return LISP.isTrue(LISP[\"eq?\"](LISP.car(clause), LISP.t)) ? LISP[\"list*\"](LISP.intern(\"do\"), LISP.cdr(clause)) : LISP.isTrue(LISP[\"null?\"](LISP.cdr(clause))) ? (function (g) {\n        return LISP.list(LISP.intern(\"let\"), LISP.list(LISP.list(g, LISP.car(clause))), LISP.list(LISP.intern(\"if\"), g, g, LISP[\"list*\"](LISP.intern(\"cond\"), rest)));\n      })(LISP.gensym()) : LISP.isTrue(LISP[\"eq?\"](LISP.cadr(clause), LISP.intern(\"=>\"))) ? (function (g) {\n        return LISP.list(LISP.intern(\"let\"), LISP.list(LISP.list(g, LISP.car(clause))), LISP.list(LISP.intern(\"if\"), g, LISP.list(LISP.caddr(clause), g), LISP[\"list*\"](LISP.intern(\"cond\"), rest)));\n      })(LISP.gensym()) : LISP.list(LISP.intern(\"if\"), LISP.car(clause), LISP[\"list*\"](LISP.intern(\"do\"), LISP.cdr(clause)), LISP[\"list*\"](LISP.intern(\"cond\"), rest));\n    })(LISP.car(clauses), LISP.cdr(clauses));\n  });\n  LISP[\"register-macro\"](LISP.intern(\"case\"), function (x) {\n    var clauses = LISP._getRestArgs(arguments, 1);return (function (value) {\n      return LISP.list(LISP.intern(\"let1\"), value, x, LISP[\"list*\"](LISP.intern(\"cond\"), LISP.map(function (clause) {\n        return LISP.isTrue(LISP[\"eq?\"](LISP.car(clause), LISP.t)) ? clause : LISP.isTrue(LISP[\"null?\"](LISP.cdar(clause))) ? LISP[\"list*\"](LISP.list(LISP.intern(\"eq?\"), value, LISP.list(LISP.intern(\"quote\"), LISP.caar(clause))), LISP.cdr(clause)) : LISP[\"list*\"](LISP.list(LISP.intern(\"member\"), value, LISP.list(LISP.intern(\"quote\"), LISP.car(clause))), LISP.cdr(clause));\n      }, clauses)));\n    })(LISP.gensym());\n  });\n  LISP[\"register-macro\"](LISP.intern(\"and\"), (function () {\n    var __3 = LISP.list(LISP.nil);return function () {\n      var args = LISP._getRestArgs(arguments, 0);return LISP.isTrue(LISP[\"null?\"](args)) ? LISP.t : LISP.isTrue(LISP[\"null?\"](LISP.cdr(args))) ? LISP.car(args) : LISP[\"list*\"](LISP.intern(\"if\"), LISP.car(args), LISP[\"list*\"](LISP.intern(\"and\"), LISP.cdr(args)), __3);\n    };\n  })());\n  LISP[\"register-macro\"](LISP.intern(\"or\"), function () {\n    var args = LISP._getRestArgs(arguments, 0);return LISP.isTrue(LISP[\"null?\"](LISP.cdr(args))) ? LISP.car(args) : (function (g) {\n      return LISP.list(LISP.intern(\"let1\"), g, LISP.car(args), LISP.list(LISP.intern(\"if\"), g, g, LISP[\"list*\"](LISP.intern(\"or\"), LISP.cdr(args))));\n    })(LISP.gensym());\n  });\n  LISP[\"register-macro\"](LISP.intern(\"do\"), function () {\n    var body = LISP._getRestArgs(arguments, 0);return LISP.isTrue(LISP[\"null?\"](body)) ? LISP.nil : LISP.isTrue(LISP[\"null?\"](LISP.cdr(body))) ? LISP.car(body) : LISP[\"list*\"](LISP.intern(\"let\"), LISP.nil, body);\n  });\n  LISP[\"register-macro\"](LISP.intern(\"aif\"), function (expr, thn) {\n    var els = LISP._getRestArgs(arguments, 2);return LISP.list(LISP.intern(\"let1\"), LISP.intern(\"it\"), expr, LISP[\"list*\"](LISP.intern(\"if\"), LISP.intern(\"it\"), thn, els));\n  });\n  LISP[\"register-macro\"](LISP.intern(\"awhen\"), function (expr) {\n    var body = LISP._getRestArgs(arguments, 1);return LISP.list(LISP.intern(\"aif\"), expr, LISP[\"list*\"](LISP.intern(\"do\"), body));\n  });\n  LISP[\"register-macro\"](LISP.intern(\"awhile\"), function (expr) {\n    var body = LISP._getRestArgs(arguments, 1);return (function (loop) {\n      return LISP.list(LISP.intern(\"let\"), loop, LISP.nil, LISP.list(LISP.intern(\"let1\"), LISP.intern(\"it\"), expr, LISP[\"list*\"](LISP.intern(\"when\"), LISP.intern(\"it\"), LISP.append(body, LISP.list(LISP.list(loop))))));\n    })(LISP.gensym());\n  });\n  LISP[\"null?\"] = function (x) {\n    return LISP[\"eq?\"](x, LISP.nil);\n  };\n  LISP.not = function (x) {\n    return LISP[\"eq?\"](x, LISP.nil);\n  };\n  LISP.caar = function (x) {\n    return LISP.car(LISP.car(x));\n  };\n  LISP.cadr = function (x) {\n    return LISP.car(LISP.cdr(x));\n  };\n  LISP.cdar = function (x) {\n    return LISP.cdr(LISP.car(x));\n  };\n  LISP.cddr = function (x) {\n    return LISP.cdr(LISP.cdr(x));\n  };\n  LISP.cadar = function (x) {\n    return LISP.cadr(LISP.car(x));\n  };\n  LISP.caddr = function (x) {\n    return LISP.car(LISP.cddr(x));\n  };\n  LISP.cdddr = function (x) {\n    return LISP.cdr(LISP.cddr(x));\n  };\n  LISP[\"equal?\"] = function (x, y) {\n    return LISP.isTrue(LISP[\"eq?\"](x, y)) ? LISP.t : (function (xtype) {\n      return LISP.isTrue(LISP[\"eq?\"](xtype, LISP.type(y))) ? (function (__4) {\n        return LISP.isTrue(LISP[\"eq?\"](__4, LISP.intern(\"pair\"))) ? LISP.isTrue(LISP[\"equal?\"](LISP.car(x), LISP.car(y))) ? LISP[\"equal?\"](LISP.cdr(x), LISP.cdr(y)) : LISP.nil : LISP.isTrue(LISP[\"eq?\"](__4, LISP.intern(\"vector\"))) ? (function (n) {\n          return LISP.isTrue(LISP[\"eq?\"](n, LISP[\"vector-length\"](y))) ? (function (loop) {\n            return loop = function (i) {\n              return (function (__5) {\n                return LISP.isTrue(__5) ? __5 : LISP.isTrue(LISP[\"equal?\"](LISP[\"vector-ref\"](x, i), LISP[\"vector-ref\"](y, i))) ? loop(i + 1) : LISP.nil;\n              })(LISP[\">=\"](i, n));\n            }, loop(0);\n          })(LISP.nil) : LISP.nil;\n        })(LISP[\"vector-length\"](x)) : LISP.nil;\n      })(xtype) : LISP.nil;\n    })(LISP.type(x));\n  };\n  LISP.length = function (ls) {\n    return (function (loop) {\n      return loop = function (ls, acc) {\n        return LISP.isTrue(LISP[\"pair?\"](ls)) ? loop(LISP.cdr(ls), acc + 1) : acc;\n      }, loop(ls, 0);\n    })(LISP.nil);\n  };\n  LISP[\"last-pair\"] = function (ls) {\n    return LISP.isTrue(LISP[\"pair?\"](LISP.cdr(ls))) ? LISP[\"last-pair\"](LISP.cdr(ls)) : ls;\n  };\n  LISP.member = function (x, ls) {\n    return LISP.isTrue(LISP[\"null?\"](ls)) ? LISP.nil : LISP.isTrue(LISP[\"eq?\"](x, LISP.car(ls))) ? ls : LISP.member(x, LISP.cdr(ls));\n  };\n  LISP.assoc = function (x, ls) {\n    return LISP.isTrue(LISP[\"null?\"](ls)) ? LISP.nil : LISP.isTrue(LISP[\"eq?\"](x, LISP.caar(ls))) ? LISP.car(ls) : LISP.assoc(x, LISP.cdr(ls));\n  };\n  LISP.acons = function (key, datum, alist) {\n    return LISP.cons(LISP.cons(key, datum), alist);\n  };\n  LISP.map = function (f, ls) {\n    return LISP.isTrue(LISP[\"null?\"](ls)) ? LISP.nil : LISP.cons(f(LISP.car(ls)), LISP.map(f, LISP.cdr(ls)));\n  };\n  LISP.append = function (ls) {\n    var rest = LISP._getRestArgs(arguments, 1);return LISP.isTrue(LISP[\"null?\"](rest)) ? ls : LISP.isTrue(LISP[\"null?\"](ls)) ? LISP.apply(LISP.append, rest) : LISP.cons(LISP.car(ls), LISP.apply(LISP.append, LISP.cdr(ls), rest));\n  };\n  LISP.reverse = function (ls) {\n    return (function (loop) {\n      return loop = function (ls, acc) {\n        return LISP.isTrue(LISP[\"pair?\"](ls)) ? loop(LISP.cdr(ls), LISP.cons(LISP.car(ls), acc)) : acc;\n      }, loop(ls, LISP.nil);\n    })(LISP.nil);\n  };\n  LISP[\"list*\"] = function () {\n    var args = LISP._getRestArgs(arguments, 0);return LISP.isTrue(LISP[\"null?\"](args)) ? LISP.nil : LISP.isTrue(LISP[\"null?\"](LISP.cdr(args))) ? LISP.car(args) : (function (loop) {\n      return loop = function (p, q) {\n        return LISP.isTrue(LISP[\"null?\"](LISP.cdr(q))) ? (function () {\n          return LISP[\"set-cdr!\"](p, LISP.car(q)), args;\n        })() : loop(q, LISP.cdr(q));\n      }, loop(args, LISP.cdr(args));\n    })(LISP.nil);\n  };\n  LISP[\"last-pair\"] = function (ls) {\n    return LISP.isTrue(LISP[\"pair?\"](LISP.cdr(ls))) ? LISP[\"last-pair\"](LISP.cdr(ls)) : ls;\n  };\n  LISP[\"proper-list?\"] = function (ls) {\n    return LISP.isTrue(LISP[\"pair?\"](ls)) ? LISP[\"null?\"](LISP.cdr(LISP[\"last-pair\"](ls))) : LISP.nil;\n  };\n  LISP[\"dotted->proper\"] = function (ls) {\n    return LISP.isTrue(LISP[\"pair?\"](ls)) ? LISP.isTrue(LISP[\"proper-list?\"](ls)) ? ls : (function (dot, rev) {\n      return (function (dup) {\n        return LISP[\"set-cdr!\"](rev, LISP.list(dot)), dup;\n      })(LISP[\"reverse!\"](rev));\n    })(LISP.cdr(LISP[\"last-pair\"](ls)), LISP.reverse(ls)) : LISP.list(ls);\n  };\n  LISP[\"vector->list\"] = function (vect) {\n    return (function (loop) {\n      return loop = function (i, acc) {\n        return LISP.isTrue(LISP[\"<\"](i, 0)) ? acc : loop(i - 1, LISP.cons(LISP[\"vector-ref\"](vect, i), acc));\n      }, loop(LISP[\"vector-length\"](vect) - 1, LISP.nil);\n    })(LISP.nil);\n  };\n  LISP[\"position-if\"] = function (pred, seq) {\n    return (function (loop) {\n      return loop = function (p, i) {\n        return LISP.isTrue(p) ? LISP.isTrue(pred(LISP.car(p))) ? i : loop(LISP.cdr(p), i + 1) : LISP.nil;\n      }, loop(seq, 0);\n    })(LISP.nil);\n  };\n  LISP.take = function (n, ls) {\n    return (function (loop) {\n      return loop = function (n, ls, acc) {\n        return LISP.isTrue((function (__6) {\n          return LISP.isTrue(__6) ? __6 : LISP[\"null?\"](ls);\n        })(LISP[\"<=\"](n, 0))) ? LISP[\"reverse!\"](acc) : loop(n - 1, LISP.cdr(ls), LISP.cons(LISP.car(ls), acc));\n      }, loop(n, ls, LISP.nil);\n    })(LISP.nil);\n  };\n  LISP.drop = function (n, ls) {\n    return LISP.isTrue((function (__7) {\n      return LISP.isTrue(__7) ? __7 : LISP[\"null?\"](ls);\n    })(LISP[\"<=\"](n, 0))) ? ls : LISP.drop(n - 1, LISP.cdr(ls));\n  };\n  LISP.elt = function (n, ls) {\n    return LISP.car(LISP.drop(n, ls));\n  };\n  LISP[\"remove-if\"] = function (test, seq) {\n    return (function (loop) {\n      return loop = function (seq, acc) {\n        return LISP.isTrue(LISP[\"null?\"](seq)) ? LISP[\"reverse!\"](acc) : loop(LISP.cdr(seq), LISP.isTrue(test(LISP.car(seq))) ? acc : LISP.cons(LISP.car(seq), acc));\n      }, loop(seq, LISP.nil);\n    })(LISP.nil);\n  };\n  LISP[\"register-macro\"](LISP.intern(\"dotimes\"), function (params) {\n    var body = LISP._getRestArgs(arguments, 1);return (function () {\n      var __8 = LISP.list(0),\n          __9 = LISP.list(1);return function (i, limit, loop) {\n        return LISP.list(LISP.intern(\"let1\"), limit, LISP.cadr(params), LISP.list(LISP.intern(\"let\"), loop, LISP.list(LISP[\"list*\"](i, __8)), LISP.list(LISP.intern(\"if\"), LISP.list(LISP.intern(\"<\"), i, limit), LISP[\"list*\"](LISP.intern(\"do\"), LISP.append(body, LISP.list(LISP.list(loop, LISP[\"list*\"](LISP.intern(\"+\"), i, __9))))), LISP.caddr(params))));\n      };\n    })()(LISP.car(params), LISP.gensym(), LISP.gensym());\n  });\n  LISP[\"register-macro\"](LISP.intern(\"dolist\"), function (pair) {\n    var body = LISP._getRestArgs(arguments, 1);return (function (i, loop, ls) {\n      return LISP.list(LISP.intern(\"let\"), loop, LISP.list(LISP.list(ls, LISP.cadr(pair))), LISP.list(LISP.intern(\"let1\"), i, LISP.list(LISP.intern(\"car\"), ls), LISP[\"list*\"](LISP.intern(\"when\"), i, LISP.append(body, LISP.list(LISP.list(loop, LISP.list(LISP.intern(\"cdr\"), ls)))))));\n    })(LISP.car(pair), LISP.gensym(), LISP.gensym());\n  });\n  LISP[\"register-macro\"](LISP.intern(\"labels\"), function (lss) {\n    var body = LISP._getRestArgs(arguments, 1);return LISP[\"list*\"](LISP.intern(\"let\"), LISP.map(function (ls) {\n      return LISP.car(ls);\n    }, lss), LISP.append(LISP.map(function (ls) {\n      return LISP.list(LISP.intern(\"set!\"), LISP.car(ls), LISP[\"list*\"](LISP.intern(\"lambda\"), LISP.cdr(ls)));\n    }, lss), body));\n  });\n  LISP.nreconc = function (ls, tail) {\n    return (function (top) {\n      return LISP[\"set-cdr!\"](ls, tail), top;\n    })(LISP[\"reverse!\"](ls));\n  };\n  LISP.any = function (f, ls) {\n    return LISP.isTrue(LISP[\"null?\"](ls)) ? LISP.nil : LISP.isTrue(f(LISP.car(ls))) ? LISP.t : LISP.any(f, LISP.cdr(ls));\n  };\n  LISP.every = function (f, ls) {\n    return LISP.isTrue(LISP[\"null?\"](ls)) ? LISP.t : LISP.isTrue(f(LISP.car(ls))) ? LISP.every(f, LISP.cdr(ls)) : LISP.nil;\n  };\n  LISP[\"*bq-clobberable*\"] = LISP.gensym();\n  LISP[\"*bq-quote-nil*\"] = LISP.list(LISP.intern(\"quote\"), LISP.nil);\n  LISP[\"register-macro\"](LISP.intern(\"quasiquote\"), function (x) {\n    return LISP[\"bq-completely-process\"](x);\n  });\n  LISP[\"bq-completely-process\"] = function (x) {\n    return LISP[\"bq-simplify\"](LISP[\"bq-process\"](x));\n  };\n  LISP[\"bq-process\"] = function (x) {\n    return LISP.isTrue(LISP.not(LISP[\"pair?\"](x))) ? LISP.list(LISP.intern(\"quote\"), x) : LISP.isTrue(LISP[\"eq?\"](LISP.car(x), LISP.intern(\"quasiquote\"))) ? LISP[\"bq-process\"](LISP[\"bq-completely-process\"](LISP.cadr(x))) : LISP.isTrue(LISP[\"eq?\"](LISP.car(x), LISP.intern(\"unquote\"))) ? LISP.cadr(x) : LISP.isTrue(LISP[\"eq?\"](LISP.car(x), LISP.intern(\"unquote-splicing\"))) ? LISP.error(\",@~S after `\", LISP.cadr(x)) : LISP.isTrue(LISP[\"eq?\"](LISP.car(x), LISP.intern(\"unquote-dot\"))) ? LISP.error(\",.~S after `\", LISP.cadr(x)) : (function (loop) {\n      return loop = function (p, q) {\n        return LISP.isTrue(LISP.not(LISP[\"pair?\"](p))) ? LISP.cons(LISP.intern(\"append\"), LISP.nreconc(q, LISP.list(LISP.list(LISP.intern(\"quote\"), p)))) : LISP.isTrue(LISP[\"eq?\"](LISP.car(p), LISP.intern(\"unquote\"))) ? (function () {\n          return LISP.isTrue(LISP[\"null?\"](LISP.cddr(p))) ? LISP.nil : LISP.error(\"Malformed ,~S\", p), LISP.cons(LISP.intern(\"append\"), LISP.nreconc(q, LISP.list(LISP.cadr(p))));\n        })() : (function () {\n          return LISP.isTrue(LISP[\"eq?\"](LISP.car(p), LISP.intern(\"unquote-splicing\"))) ? LISP.error(\"Dotted ,@~S\", p) : LISP.nil, LISP.isTrue(LISP[\"eq?\"](LISP.car(p), LISP.intern(\"unquote-dot\"))) ? LISP.error(\"Dotted ,.~S\", p) : LISP.nil, loop(LISP.cdr(p), LISP.cons(LISP.bracket(LISP.car(p)), q));\n        })();\n      }, loop(x, LISP.nil);\n    })(LISP.nil);\n  };\n  LISP.bracket = function (x) {\n    return LISP.isTrue(LISP.not(LISP[\"pair?\"](x))) ? LISP.list(LISP.intern(\"list\"), LISP[\"bq-process\"](x)) : LISP.isTrue(LISP[\"eq?\"](LISP.car(x), LISP.intern(\"unquote\"))) ? LISP.list(LISP.intern(\"list\"), LISP.cadr(x)) : LISP.isTrue(LISP[\"eq?\"](LISP.car(x), LISP.intern(\"unquote-splicing\"))) ? LISP.cadr(x) : LISP.isTrue(LISP[\"eq?\"](LISP.car(x), LISP.intern(\"unquote-dot\"))) ? LISP.list(LISP[\"*bq-clobberable*\"], LISP.cadr(x)) : LISP.list(LISP.intern(\"list\"), LISP[\"bq-process\"](x));\n  };\n  LISP.maptree = function (fn, x) {\n    return LISP.isTrue(LISP.not(LISP[\"pair?\"](x))) ? fn(x) : (function (a, d) {\n      return LISP.isTrue(LISP.isTrue(LISP[\"equal?\"](a, LISP.car(x))) ? LISP[\"equal?\"](d, LISP.cdr(x)) : LISP.nil) ? x : LISP.cons(a, d);\n    })(fn(LISP.car(x)), LISP.maptree(fn, LISP.cdr(x)));\n  };\n  LISP[\"bq-splicing-frob\"] = function (x) {\n    return LISP.isTrue(LISP[\"pair?\"](x)) ? (function (__2) {\n      return LISP.isTrue(__2) ? __2 : LISP[\"eq?\"](LISP.car(x), LISP.intern(\"unquote-dot\"));\n    })(LISP[\"eq?\"](LISP.car(x), LISP.intern(\"unquote-splicing\"))) : LISP.nil;\n  };\n  LISP[\"bq-frob\"] = function (x) {\n    return LISP.isTrue(LISP[\"pair?\"](x)) ? (function (__3) {\n      return LISP.isTrue(__3) ? __3 : (function (__4) {\n        return LISP.isTrue(__4) ? __4 : LISP[\"eq?\"](LISP.car(x), LISP.intern(\"unquote-dot\"));\n      })(LISP[\"eq?\"](LISP.car(x), LISP.intern(\"unquote-splicing\")));\n    })(LISP[\"eq?\"](LISP.car(x), LISP.intern(\"unquote\"))) : LISP.nil;\n  };\n  LISP[\"bq-simplify\"] = function (x) {\n    return LISP.isTrue(LISP[\"pair?\"](x)) ? (function (x) {\n      return LISP.isTrue(LISP.not(LISP[\"eq?\"](LISP.car(x), LISP.intern(\"append\")))) ? x : LISP[\"bq-simplify-args\"](x);\n    })(LISP.isTrue(LISP[\"eq?\"](LISP.car(x), LISP.intern(\"quote\"))) ? x : LISP.maptree(LISP[\"bq-simplify\"], x)) : x;\n  };\n  LISP[\"bq-simplify-args\"] = function (x) {\n    return (function (loop) {\n      return loop = function (args, result) {\n        return LISP.isTrue(LISP.not(LISP[\"null?\"](args))) ? loop(LISP.cdr(args), LISP.isTrue(LISP.not(LISP[\"pair?\"](LISP.car(args)))) ? LISP[\"bq-attach-append\"](LISP.intern(\"append\"), LISP.car(args), result) : LISP.isTrue(LISP.isTrue(LISP[\"eq?\"](LISP.caar(args), LISP.intern(\"list\"))) ? LISP.not(LISP.any(LISP[\"bq-splicing-frob\"], LISP.cdar(args))) : LISP.nil) ? LISP[\"bq-attach-conses\"](LISP.cdar(args), result) : LISP.isTrue(LISP.isTrue(LISP[\"eq?\"](LISP.caar(args), LISP.intern(\"list*\"))) ? LISP.not(LISP.any(LISP[\"bq-splicing-frob\"], LISP.cdar(args))) : LISP.nil) ? LISP[\"bq-attach-conses\"](LISP.reverse(LISP.cdr(LISP.reverse(LISP.cdar(args)))), LISP[\"bq-attach-append\"](LISP.intern(\"append\"), LISP.car(LISP.last(LISP.car(args))), result)) : LISP.isTrue(LISP.isTrue(LISP[\"eq?\"](LISP.caar(args), LISP.intern(\"quote\"))) ? LISP.isTrue(LISP[\"pair?\"](LISP.cadar(args))) ? LISP.isTrue(LISP.not(LISP[\"bq-frob\"](LISP.cadar(args)))) ? LISP.not(LISP.cddar(args)) : LISP.nil : LISP.nil : LISP.nil) ? LISP[\"bq-attach-conses\"](LISP.list(LISP.list(LISP.intern(\"quote\"), LISP.caadar(args))), result) : LISP.isTrue(LISP[\"eq?\"](LISP.caar(args), LISP[\"*bq-clobberable*\"])) ? LISP[\"bq-attach-append\"](LISP.intern(\"append!\"), LISP.cadar(args), result) : LISP[\"bq-attach-append\"](LISP.intern(\"append\"), LISP.car(args), result)) : result;\n      }, loop(LISP.reverse(LISP.cdr(x)), LISP.nil);\n    })(LISP.nil);\n  };\n  LISP[\"null-or-quoted\"] = function (x) {\n    return (function (__5) {\n      return LISP.isTrue(__5) ? __5 : LISP.isTrue(LISP[\"pair?\"](x)) ? LISP[\"eq?\"](LISP.car(x), LISP.intern(\"quote\")) : LISP.nil;\n    })(LISP[\"null?\"](x));\n  };\n  LISP[\"bq-attach-append\"] = function (op, item, result) {\n    return LISP.isTrue(LISP.isTrue(LISP[\"null-or-quoted\"](item)) ? LISP[\"null-or-quoted\"](result) : LISP.nil) ? LISP.list(LISP.intern(\"quote\"), LISP.append(LISP.cadr(item), LISP.cadr(result))) : LISP.isTrue((function (__6) {\n      return LISP.isTrue(__6) ? __6 : LISP[\"equal?\"](result, LISP[\"*bq-quote-nil*\"]);\n    })(LISP[\"null?\"](result))) ? LISP.isTrue(LISP[\"bq-splicing-frob\"](item)) ? LISP.list(op, item) : item : LISP.isTrue(LISP.isTrue(LISP[\"pair?\"](result)) ? LISP[\"eq?\"](LISP.car(result), op) : LISP.nil) ? LISP[\"list*\"](LISP.car(result), item, LISP.cdr(result)) : LISP.list(op, item, result);\n  };\n  LISP[\"bq-attach-conses\"] = function (items, result) {\n    return LISP.isTrue(LISP.isTrue(LISP.every(LISP[\"null-or-quoted\"], items)) ? LISP[\"null-or-quoted\"](result) : LISP.nil) ? LISP.list(LISP.intern(\"quote\"), LISP.append(LISP.map(LISP.cadr, items), LISP.cadr(result))) : LISP.isTrue((function (__7) {\n      return LISP.isTrue(__7) ? __7 : LISP[\"equal?\"](result, LISP[\"*bq-quote-nil*\"]);\n    })(LISP[\"null?\"](result))) ? LISP.cons(LISP.intern(\"list\"), items) : LISP.isTrue(LISP.isTrue(LISP[\"pair?\"](result)) ? (function (__8) {\n      return LISP.isTrue(__8) ? __8 : LISP[\"eq?\"](LISP.car(result), LISP.intern(\"list*\"));\n    })(LISP[\"eq?\"](LISP.car(result), LISP.intern(\"list\"))) : LISP.nil) ? LISP.cons(LISP.car(result), LISP.append(items, LISP.cdr(result))) : LISP.cons(LISP.intern(\"list*\"), LISP.append(items, LISP.list(result)));\n  };\n  LISP.macroexpand = function (exp) {\n    return (function (expanded) {\n      return LISP.isTrue(LISP[\"equal?\"](expanded, exp)) ? exp : LISP.macroexpand(expanded);\n    })(LISP[\"macroexpand-1\"](exp));\n  };\n  LISP[\"create-scope\"] = function (parent$2dscope, params) {\n    return LISP.vector(LISP[\"remove-if\"]((function () {\n      var __2 = LISP.list(LISP.intern(\"&rest\"), LISP.intern(\"&body\"));return function (x) {\n        return LISP.member(x, __2);\n      };\n    })(), params), LISP.nil, parent$2dscope);\n  };\n  LISP[\"scope-param\"] = function (scope) {\n    return LISP[\"vector-ref\"](scope, 0);\n  };\n  LISP[\"scope-outer\"] = function (scope) {\n    return LISP[\"vector-ref\"](scope, 2);\n  };\n  LISP[\"scope-add-var\"] = function (scope, val) {\n    return (function (x) {\n      return LISP[\"vector-set!\"](scope, 1, LISP.cons(LISP.cons(x, val), LISP[\"vector-ref\"](scope, 1))), LISP[\"vector-set!\"](scope, 0, LISP.cons(x, LISP[\"vector-ref\"](scope, 0))), x;\n    })(LISP.gensym());\n  };\n  LISP[\"scope-get-var\"] = function (scope) {\n    return LISP[\"vector-ref\"](scope, 1);\n  };\n  LISP[\"scope-var?\"] = function (scope, x) {\n    return LISP.isTrue(LISP[\"null?\"](scope)) ? LISP.nil : LISP.isTrue(LISP.member(x, LISP[\"scope-param\"](scope))) ? LISP.t : LISP[\"scope-var?\"](LISP[\"scope-outer\"](scope), x);\n  };\n  LISP[\"local-var?\"] = function (scope, sym) {\n    return LISP.isTrue(LISP[\"symbol?\"](sym)) ? LISP[\"scope-var?\"](scope, LISP[\"get-receiver\"](sym)) : LISP.nil;\n  };\n  LISP[\"get-receiver\"] = function (sym) {\n    return (function (s) {\n      return (function (it) {\n        return LISP.isTrue(it) ? LISP.intern(LISP.substring(s, 0, it)) : sym;\n      })(LISP[\"string-scan\"](s, \".\"));\n    })(LISP[\"symbol->string\"](sym));\n  };\n  LISP[\"register-macro\"](LISP.intern(\"record\"), function (args, param) {\n    var body = LISP._getRestArgs(arguments, 2);return LISP.list(LISP.intern(\"apply\"), LISP[\"list*\"](LISP.intern(\"lambda\"), param, body), args);\n  });\n  LISP[\"register-macro\"](LISP.intern(\"record-case\"), function (x) {\n    var clauses = LISP._getRestArgs(arguments, 1);return (function (value) {\n      return LISP.list(LISP.intern(\"let1\"), value, x, LISP[\"list*\"](LISP.intern(\"case\"), LISP.list(LISP.intern(\"car\"), value), LISP.map(function (clause) {\n        return LISP.isTrue(LISP[\"eq?\"](LISP.car(clause), LISP.t)) ? clause : (function (key) {\n          return LISP.list(LISP.list(key), LISP[\"list*\"](LISP.intern(\"record\"), LISP.list(LISP.intern(\"cdr\"), value), LISP.cdar(clause), LISP.cdr(clause)));\n        })(LISP.caar(clause));\n      }, clauses)));\n    })(LISP.gensym());\n  });\n  (function (traverse$2dargs, confirm$2dvalid$2dparams, traverse$2dquoted$2dvalue) {\n    return traverse$2dargs = function (args, scope) {\n      return LISP.map(function (x) {\n        return LISP[\"traverse*\"](x, scope);\n      }, args);\n    }, confirm$2dvalid$2dparams = function (params) {\n      return LISP.isTrue(params) ? LISP.isTrue(LISP[\"symbol?\"](LISP.car(params))) ? confirm$2dvalid$2dparams(LISP.cdr(params)) : LISP[\"compile-error\"](\"function parameter must be symbol, but\", LISP.car(params)) : LISP.nil;\n    }, traverse$2dquoted$2dvalue = function (x) {\n      return LISP.isTrue(LISP[\"pair?\"](x)) ? LISP.vector(LISP[\"make-keyword\"](\"FUNCALL\"), LISP.vector(LISP[\"make-keyword\"](\"REF\"), LISP.isTrue(LISP[\"proper-list?\"](x)) ? LISP.intern(\"list\") : LISP.intern(\"list*\")), LISP.map(traverse$2dquoted$2dvalue, LISP[\"dotted->proper\"](x))) : LISP.vector(LISP[\"make-keyword\"](\"CONST\"), x);\n    }, LISP[\"traverse-list\"] = function (s, scope) {\n      return (function (__3) {\n        return (function (__4) {\n          return LISP.isTrue(LISP[\"eq?\"](__4, LISP.intern(\"quote\"))) ? LISP.apply(function (x) {\n            return LISP.isTrue(LISP[\"pair?\"](x)) ? LISP.vector(LISP[\"make-keyword\"](\"REF\"), LISP[\"scope-add-var\"](scope, traverse$2dquoted$2dvalue(x))) : LISP.vector(LISP[\"make-keyword\"](\"CONST\"), x);\n          }, LISP.cdr(__3)) : LISP.isTrue(LISP[\"eq?\"](__4, LISP.intern(\"if\"))) ? LISP.apply(function (p, thn) {\n            var els = LISP._getRestArgs(arguments, 2);return LISP.vector(LISP[\"make-keyword\"](\"IF\"), LISP[\"traverse*\"](p, scope), LISP[\"traverse*\"](thn, scope), LISP.isTrue(LISP[\"null?\"](els)) ? LISP.nil : LISP[\"traverse*\"](LISP.car(els), scope));\n          }, LISP.cdr(__3)) : LISP.isTrue(LISP[\"eq?\"](__4, LISP.intern(\"set!\"))) ? LISP.apply(function (x, v) {\n            return LISP.vector(LISP[\"make-keyword\"](\"SET!\"), LISP[\"traverse*\"](x, scope), LISP[\"traverse*\"](v, scope));\n          }, LISP.cdr(__3)) : LISP.isTrue(LISP[\"eq?\"](__4, LISP.intern(\"lambda\"))) ? LISP.apply(function (params) {\n            var body = LISP._getRestArgs(arguments, 1);return (function () {\n              return confirm$2dvalid$2dparams(params), (function (new$2dscope) {\n                return LISP.vector(LISP[\"make-keyword\"](\"LAMBDA\"), new$2dscope, params, traverse$2dargs(body, new$2dscope));\n              })(LISP[\"create-scope\"](scope, params));\n            })();\n          }, LISP.cdr(__3)) : LISP.isTrue(LISP[\"eq?\"](__4, LISP.intern(\"def\"))) ? LISP.apply(function (name, value) {\n            return LISP.vector(LISP[\"make-keyword\"](\"DEF\"), LISP[\"traverse*\"](name, scope), LISP[\"traverse*\"](value, scope));\n          }, LISP.cdr(__3)) : LISP.isTrue(LISP[\"eq?\"](__4, LISP.intern(\"new\"))) ? LISP.apply(function (klass) {\n            var args = LISP._getRestArgs(arguments, 1);return LISP.vector(LISP[\"make-keyword\"](\"NEW\"), klass, traverse$2dargs(args, LISP[\"new-scope\"]));\n          }, LISP.cdr(__3)) : LISP.vector(LISP[\"make-keyword\"](\"FUNCALL\"), LISP[\"traverse*\"](LISP.car(s), scope), traverse$2dargs(LISP.cdr(s), scope));\n        })(LISP.car(__3));\n      })(s);\n    };\n  })(LISP.nil, LISP.nil, LISP.nil);\n  LISP[\"traverse*\"] = function (s, scope) {\n    return LISP.isTrue(LISP[\"pair?\"](s)) ? LISP.isTrue(LISP[\"local-var?\"](scope, LISP.car(s))) ? LISP[\"traverse-list\"](s, scope) : (function (expanded) {\n      return LISP.isTrue(LISP[\"pair?\"](expanded)) ? LISP[\"traverse-list\"](expanded, scope) : LISP[\"traverse*\"](expanded, scope);\n    })(LISP.macroexpand(s)) : LISP.isTrue(LISP[\"symbol?\"](s)) ? LISP.vector(LISP[\"make-keyword\"](\"REF\"), s) : LISP.vector(LISP[\"make-keyword\"](\"CONST\"), s);\n  };\n  LISP[\"expand-args\"] = function (args, scope) {\n    return LISP[\"string-join\"](LISP.map(function (x) {\n      return LISP[\"compile*\"](x, scope);\n    }, args), \", \");\n  };\n  LISP[\"expand-body\"] = function (body, scope) {\n    return LISP.isTrue(LISP[\"null?\"](body)) ? \"LISP.nil\" : LISP[\"expand-args\"](body, scope);\n  };\n  (function (table) {\n    return LISP[\"hash-table-put!\"](table, \"\\\\\", \"\\\\\\\\\"), LISP[\"hash-table-put!\"](table, \"\\t\", \"\\\\t\"), LISP[\"hash-table-put!\"](table, \"\\n\", \"\\\\n\"), LISP[\"hash-table-put!\"](table, \"\\\"\", \"\\\\\\\"\"), LISP[\"escape-char\"] = function (c) {\n      return (function (__5) {\n        return LISP.isTrue(__5) ? __5 : c;\n      })(LISP[\"hash-table-get\"](table, c));\n    };\n  })(LISP[\"make-hash-table\"]());\n  LISP[\"escape-string\"] = function (s) {\n    return LISP[\"regexp-replace-all\"](/[\\\\\\t\\n\"]/, s, function (m) {\n      return LISP[\"escape-char\"](m());\n    });\n  };\n  LISP[\"escape-sym-char\"] = function (c) {\n    return LISP[\"string-append\"](\"$\", LISP[\"integer->hex-string\"](LISP[\"char->integer\"](c), \"00\"));\n  };\n  LISP[\"integer->hex-string\"] = function (x, padding) {\n    return (function (s) {\n      return (function (sl) {\n        return (function (pl) {\n          return LISP.substring(s, sl - pl, sl);\n        })(LISP[\"string-length\"](padding));\n      })(LISP[\"string-length\"](s));\n    })(LISP[\"string-append\"](padding, LISP[\"number->string\"](x, 16)));\n  };\n  LISP[\"escape-symbol\"] = function (sym) {\n    return LISP[\"regexp-replace-all\"](/[^0-9A-Za-z_.]/, LISP[\"symbol->string\"](sym), function (m) {\n      return LISP[\"escape-sym-char\"](LISP[\"string-ref\"](m(), 0));\n    });\n  };\n  LISP[\"compile-symbol\"] = function (sym, scope) {\n    return LISP.isTrue(LISP[\"local-var?\"](scope, sym)) ? LISP[\"escape-symbol\"](sym) : (function (s) {\n      return LISP.isTrue(LISP.rxmatch(/^[0-9A-Za-z_.]*$/, s)) ? LISP[\"string-append\"](\"LISP.\", s) : LISP[\"string-append\"](\"LISP[\\\"\", LISP[\"escape-string\"](s), \"\\\"]\");\n    })(LISP[\"symbol->string\"](sym));\n  };\n  LISP[\"compile-keyword\"] = function (keyword) {\n    return LISP[\"string-append\"](\"LISP[\\\"make-keyword\\\"](\\\"\", LISP[\"escape-string\"](LISP[\"keyword->string\"](keyword)), \"\\\")\");\n  };\n  LISP[\"compile-vector\"] = function (vect, scope) {\n    return LISP[\"string-append\"](\"[\", LISP[\"string-join\"](LISP.map(function (x) {\n      return LISP[\"compile-quote\"](x, scope);\n    }, LISP[\"vector->list\"](vect)), \", \"), \"]\");\n  };\n  LISP[\"compile-regexp\"] = function (regex) {\n    return LISP[\"string-append\"](\"/\", LISP[\"regexp->string\"](regex), \"/\");\n  };\n  LISP[\"compile-literal\"] = function (s, scope) {\n    return LISP.isTrue(LISP[\"number?\"](s)) ? LISP[\"number->string\"](s) : LISP.isTrue(LISP[\"symbol?\"](s)) ? LISP[\"compile-symbol\"](s, scope) : LISP.isTrue(LISP[\"keyword?\"](s)) ? LISP[\"compile-keyword\"](s) : LISP.isTrue(LISP[\"string?\"](s)) ? LISP[\"x->string\"](s, LISP.t) : LISP.isTrue(LISP[\"vector?\"](s)) ? LISP[\"compile-vector\"](s, scope) : LISP.isTrue(LISP[\"regexp?\"](s)) ? LISP[\"compile-regexp\"](s) : LISP.isTrue(LISP[\"null?\"](s)) ? \"LISP.nil\" : LISP.isTrue(LISP[\"eq?\"](s, LISP.t)) ? \"LISP.t\" : LISP.error(LISP[\"string-append\"](\"compile-literal: [\", s, \"]\"));\n  };\n  LISP[\"unary-op?\"] = (function () {\n    var __6 = LISP.list(LISP.intern(\"+\"), LISP.intern(\"-\"), LISP.intern(\"!\"), LISP.intern(\"~\"));return function (sym) {\n      return LISP.member(sym, __6);\n    };\n  })();\n  LISP[\"compile-unary-op\"] = function (fn, arg, scope) {\n    return LISP[\"string-append\"](\"(\", LISP[\"symbol->string\"](fn), LISP[\"compile*\"](arg, scope), \")\");\n  };\n  LISP[\"binop?\"] = (function () {\n    var __7 = LISP.list(LISP.intern(\"+\"), LISP.intern(\"-\"), LISP.intern(\"*\"), LISP.intern(\"/\"), LISP.intern(\"%\"));return function (sym) {\n      return LISP.member(sym, __7);\n    };\n  })();\n  LISP[\"compile-binop\"] = function (fn, args, scope) {\n    return LISP[\"string-append\"](\"(\", LISP[\"string-join\"](LISP.map(function (x) {\n      return LISP[\"compile*\"](x, scope);\n    }, args), LISP[\"string-append\"](\" \", LISP[\"symbol->string\"](fn), \" \")), \")\");\n  };\n  LISP[\"do-compile-funcall\"] = function (fn, args, scope) {\n    return LISP[\"string-append\"](LISP[\"compile*\"](fn, scope), \"(\", LISP[\"expand-args\"](args, scope), \")\");\n  };\n  LISP[\"compile-funcall\"] = function (fn, args, scope) {\n    return LISP.isTrue(LISP.isTrue(LISP[\"eq?\"](LISP[\"vector-ref\"](fn, 0), LISP[\"make-keyword\"](\"REF\"))) ? LISP.isTrue(LISP.not(LISP[\"local-var?\"](scope, LISP[\"vector-ref\"](fn, 1)))) ? LISP.not(LISP[\"null?\"](args)) : LISP.nil : LISP.nil) ? (function (fnsym) {\n      return LISP.isTrue(LISP.isTrue(LISP[\"binop?\"](fnsym)) ? LISP.not(LISP[\"null?\"](LISP.cdr(args))) : LISP.nil) ? LISP[\"compile-binop\"](fnsym, args, scope) : LISP.isTrue(LISP.isTrue(LISP[\"unary-op?\"](fnsym)) ? LISP[\"null?\"](LISP.cdr(args)) : LISP.nil) ? LISP[\"compile-unary-op\"](fnsym, LISP.car(args), scope) : LISP[\"do-compile-funcall\"](fn, args, scope);\n    })(LISP[\"vector-ref\"](fn, 1)) : LISP[\"do-compile-funcall\"](fn, args, scope);\n  };\n  LISP[\"compile-quote\"] = function (x, scope) {\n    return LISP.isTrue(LISP[\"pair?\"](x)) ? LISP[\"compile*\"](LISP.list(LISP.intern(\"cons\"), LISP.list(LISP.intern(\"quote\"), LISP.car(x)), LISP.list(LISP.intern(\"quote\"), LISP.cdr(x))), scope) : LISP.isTrue(LISP[\"symbol?\"](x)) ? LISP[\"string-append\"](\"LISP.intern(\\\"\", LISP[\"escape-string\"](LISP[\"symbol->string\"](x)), \"\\\")\") : LISP.isTrue(LISP[\"keyword?\"](x)) ? LISP[\"compile-keyword\"](x) : LISP[\"compile-literal\"](x, scope);\n  };\n  LISP[\"compile-if\"] = function (pred$2dnode, then$2dnode, else$2dnode, scope) {\n    return LISP[\"string-append\"](\"(LISP.isTrue(\", LISP[\"compile*\"](pred$2dnode, scope), \") ? (\", LISP[\"compile*\"](then$2dnode, scope), \") : (\", LISP.isTrue(else$2dnode) ? LISP[\"compile*\"](else$2dnode, scope) : \"LISP.nil\", \"))\");\n  };\n  LISP[\"compile-set!\"] = function (sym, val, scope) {\n    return LISP[\"string-append\"](LISP[\"compile*\"](sym, scope), \" = \", LISP[\"compile*\"](val, scope));\n  };\n  LISP[\"compile-lambda\"] = function (params, bodies, base$2dscope, extended$2dscope) {\n    return LISP.isTrue((function (__8) {\n      return LISP.isTrue(__8) ? __8 : LISP[\"pair?\"](params);\n    })(LISP[\"null?\"](params))) ? LISP.nil : LISP.error(\"function parameters must be a list\"), (function (rest$2dpos) {\n      return (function (proper$2dparams, rest) {\n        return LISP[\"string-append\"](\"(function(\", LISP[\"string-join\"](LISP.map(function (x) {\n          return LISP[\"escape-symbol\"](x);\n        }, proper$2dparams), \", \"), \"){\", LISP.isTrue(LISP[\"null?\"](rest)) ? \"\" : LISP[\"string-append\"](\"var \", LISP[\"escape-symbol\"](rest), \" = LISP._getRestArgs(arguments, \", LISP[\"number->string\"](LISP.length(proper$2dparams)), \"); \"), \"return (\", LISP[\"expand-body\"](bodies, extended$2dscope), \");})\");\n      })(LISP.isTrue(rest$2dpos) ? LISP.take(rest$2dpos, params) : params, LISP.isTrue(rest$2dpos) ? LISP.elt(rest$2dpos + 1, params) : LISP.nil);\n    })(LISP[\"position-if\"]((function () {\n      var __9 = LISP.list(LISP.intern(\"&rest\"), LISP.intern(\"&body\"));return function (sym) {\n        return LISP.member(sym, __9);\n      };\n    })(), params));\n  };\n  LISP[\"compile-def\"] = function (name, value, scope) {\n    return LISP[\"string-append\"](LISP[\"compile*\"](name, scope), \" = \", LISP[\"compile*\"](value, scope));\n  };\n  LISP[\"compile-new\"] = function (class$2dname, args, scope) {\n    return LISP[\"string-append\"](\"new \", LISP[\"symbol->string\"](class$2dname), \"(\", LISP[\"expand-args\"](args, scope), \")\");\n  };\n  LISP[\"compile-new-scope\"] = function (scope, compiled$2dbody) {\n    return (function (it) {\n      return LISP.isTrue(it) ? LISP[\"string-append\"](\"(function() { var \", LISP[\"string-join\"](LISP.map(function (x) {\n        return LISP[\"string-append\"](LISP[\"escape-symbol\"](LISP.car(x)), \" = \", LISP[\"compile*\"](LISP.cdr(x), scope));\n      }, LISP.reverse(it)), \", \"), \"; return \", compiled$2dbody, \"; })()\") : compiled$2dbody;\n    })(LISP[\"scope-get-var\"](scope));\n  };\n  LISP[\"compile*\"] = function (s, scope) {\n    return (function (__10) {\n      return LISP.isTrue(LISP[\"eq?\"](__10, LISP[\"make-keyword\"](\"CONST\"))) ? LISP[\"compile-quote\"](LISP[\"vector-ref\"](s, 1), scope) : LISP.isTrue(LISP[\"eq?\"](__10, LISP[\"make-keyword\"](\"REF\"))) ? LISP[\"compile-symbol\"](LISP[\"vector-ref\"](s, 1), scope) : LISP.isTrue(LISP[\"eq?\"](__10, LISP[\"make-keyword\"](\"IF\"))) ? (function (p, thn, els) {\n        return LISP[\"compile-if\"](p, thn, els, scope);\n      })(LISP[\"vector-ref\"](s, 1), LISP[\"vector-ref\"](s, 2), LISP[\"vector-ref\"](s, 3)) : LISP.isTrue(LISP[\"eq?\"](__10, LISP[\"make-keyword\"](\"FUNCALL\"))) ? LISP[\"compile-funcall\"](LISP[\"vector-ref\"](s, 1), LISP[\"vector-ref\"](s, 2), scope) : LISP.isTrue(LISP[\"eq?\"](__10, LISP[\"make-keyword\"](\"SET!\"))) ? LISP[\"compile-set!\"](LISP[\"vector-ref\"](s, 1), LISP[\"vector-ref\"](s, 2), scope) : LISP.isTrue(LISP[\"eq?\"](__10, LISP[\"make-keyword\"](\"LAMBDA\"))) ? (function (extended$2dscope, params, body) {\n        return LISP[\"compile-new-scope\"](extended$2dscope, LISP[\"compile-lambda\"](params, body, scope, extended$2dscope));\n      })(LISP[\"vector-ref\"](s, 1), LISP[\"vector-ref\"](s, 2), LISP[\"vector-ref\"](s, 3)) : LISP.isTrue(LISP[\"eq?\"](__10, LISP[\"make-keyword\"](\"DEF\"))) ? LISP[\"compile-def\"](LISP[\"vector-ref\"](s, 1), LISP[\"vector-ref\"](s, 2), scope) : LISP.isTrue(LISP[\"eq?\"](__10, LISP[\"make-keyword\"](\"NEW\"))) ? LISP[\"compile-new\"](LISP[\"vector-ref\"](s, 1), LISP[\"vector-ref\"](s, 2), scope) : LISP[\"compile-error\"](\"Unknown AST node:\", s);\n    })(LISP[\"vector-ref\"](s, 0));\n  };\n  LISP[\"compile-error\"] = function () {\n    var args = LISP._getRestArgs(arguments, 0);return LISP.error(args);\n  };\n  LISP.compile = function (s) {\n    return (function (top$2dscope) {\n      return (function (tree) {\n        return LISP[\"compile-new-scope\"](top$2dscope, LISP[\"compile*\"](tree, top$2dscope));\n      })(LISP[\"traverse*\"](s, top$2dscope));\n    })(LISP[\"create-scope\"](LISP.nil, LISP.nil));\n  };\n\n  return LISP;\n}, function (LISP) {\n  // Using eval JS function prevent uglify to mangle local variable names,\n  // so put such code here.\n  LISP.eval = function (exp) {\n    return eval(LISP.compile(exp));\n  };\n});\n\n","((createLisp, installEval) => {\n  'use strict'\n\n  const g = ((typeof window !== 'undefined') ? window :\n             (typeof GLOBAL !== 'undefined') ? GLOBAL : {})\n\n  const LISP = createLisp(g)\n  installEval(LISP)\n\n  if (typeof module !== 'undefined')\n    module.exports = LISP\n  else\n    g.LISP = LISP\n})((global) => {\n  'use strict'\n\n  const LISP = {}\n\n  // Convert JS array into Lisp list.\n  const arrayToList = (array) => {\n    let result = LISP.nil\n    for (let i = array.length; --i >= 0; )\n      result = LISP.cons(array[i], result)\n    return result\n  }\n\n  const jsBoolToS = x => x ? LISP.t : LISP.nil\n  const arguments2Array = (args, start) => {\n    const len = args.length - start\n    if (len <= 0)\n      return []\n    const array = new Array(len)\n    for (let i = 0; i < len; ++i)\n      array[i] = args[i + start]\n    return array\n  }\n\n  const makeString = (x, inspect) => {\n    if (x === LISP.nil)\n      return 'nil'\n    if (x === LISP.t)\n      return 't'\n    if (typeof x == 'string')\n      return inspect ? inspectString(x) : x\n    if (x instanceof Array)\n      return '#(' + x.map(v => makeString(v, inspect)).join(' ') + ')'\n    if (x == null)  // null or undefined\n      return '' + x\n    return x.toString(inspect)\n  }\n\n  LISP.nil = false\n  LISP.t = true\n\n  LISP.isTrue = (x) => {\n    return x !== LISP.nil && x != null  // !(false || null || undefined)\n  }\n\n  LISP._getRestArgs = (args, start) => {\n    return arrayToList(Array.prototype.slice.call(args, start))\n  }\n  LISP._output = (typeof(process) !== 'undefined'\n                  ? (str) => {  // for node.js.\n                    process.stdout.write(str)\n                  } : (str) => {  // for browser.\n                    console.log(str)\n                  })\n\n  const macroTable = {}\n  LISP['register-macro'] = (name, func) => {\n    macroTable[name] = func\n    return name\n  }\n  LISP['macroexpand-1'] = (s) => {\n    if (!LISP['pair?'](s) || !(s.car in macroTable))\n      return s\n    const macrofn = macroTable[s.car]\n    return LISP.apply(macrofn, s.cdr)\n  }\n\n  LISP.error = function() {\n    throw arguments2Array(arguments, 0).join(', ')\n  }\n\n  // Symbol.\n  class Symbol {\n    constructor(name) {\n      this.name = name\n    }\n\n    toString() {\n      return this.name\n    }\n  }\n\n  LISP['symbol->string'] = x => x.name\n\n  LISP.intern = (() => {\n    const symbolTable = {}  // key(string) => Symbol object\n    return (name) => {\n      if (name in symbolTable)\n        return symbolTable[name]\n      return symbolTable[name] = new Symbol(name)\n    }\n  })()\n  LISP.gensym = (() => {\n    let index = 0\n    return () => {\n      return LISP.intern('__' + (++index))\n    }\n  })()\n  LISP['symbol?'] = x => jsBoolToS(x instanceof Symbol)\n\n  class Keyword {\n    constructor(name) {\n      this.name = name\n    }\n\n    toString(inspect) {\n      return inspect ? ':' + this.name : this.name\n    }\n  }\n  LISP['make-keyword'] = (() => {\n    const keywordTable = {}  // key(string) => Keyword object\n    return (name) => {\n      if (name in keywordTable)\n        return keywordTable[name]\n      return keywordTable[name] = new Keyword(name)\n    }\n  })()\n  LISP['keyword?'] = x => jsBoolToS(x instanceof Keyword)\n  LISP['keyword->string'] = x => x.name\n\n  LISP.type = (x) => {\n    let type\n    if (x === LISP.nil || x === LISP.t)\n      type = 'bool'\n    else {\n      type = typeof x\n      if (type === 'object') {\n        if (x instanceof Symbol)\n          type = 'symbol'\n        else if (x instanceof Keyword)\n          type = 'keyword'\n        else if (x instanceof Cons)\n          type = 'pair'\n        else if (x instanceof Array)\n          type = 'vector'\n        else if (x instanceof HashTable)\n          type = 'table'\n      }\n    }\n    return LISP.intern(type)\n  }\n\n  LISP['eq?'] = (x, y) => jsBoolToS(x === y)\n\n  // Cons cell.\n  const abbrevTable = {quote: '\\'', quasiquote: '`', unquote: ',', 'unquote-splicing': ',@'}\n  class Cons {\n    constructor(car, cdr, lineNo, path) {\n      this.car = car\n      this.cdr = cdr\n\n      if (lineNo != null) {\n        this.lineNo = lineNo\n        this.path = path\n      }\n    }\n\n    toString(inspect) {\n      if (this.car instanceof Symbol &&  // (symbol? car)\n          this.cdr instanceof Cons &&    // (pair? cdr)\n          this.cdr.cdr &&                // (null? (cdr cdr))\n          this.car.name in abbrevTable) {\n        return abbrevTable[this.car.name] + makeString(this.cdr.car, inspect)\n      }\n\n      const ss = []\n      let separator = '('\n      let p\n      for (p = this; p instanceof Cons; p = p.cdr) {\n        ss.push(separator)\n        ss.push(makeString(p.car, inspect))\n        separator = ' '\n      }\n      if (p !== LISP.nil) {\n        ss.push(' . ')\n        ss.push(makeString(p, inspect))\n      }\n      ss.push(')')\n      return ss.join('')\n    }\n\n    toArray() {\n      const result = []\n      for (let p = this; p instanceof Cons; p = p.cdr)\n        result.push(p.car)\n      return result\n    }\n  }\n\n  LISP.cons = (car, cdr) => new Cons(car, cdr)\n  LISP.car = (s) => {\n    if (s instanceof Cons)\n      return s.car\n    return s\n  }\n  LISP.cdr = (s) => {\n    if (s instanceof Cons)\n      return s.cdr\n    return LISP.nil\n  }\n  LISP['set-car!'] = (s, x) => (s.car = x)\n  LISP['set-cdr!'] = (s, x) => (s.cdr = x)\n\n  LISP['pair?'] = x => jsBoolToS(x instanceof Cons)\n  LISP.list = function() {\n    let result = LISP.nil\n    for (let i = arguments.length; --i >= 0; )\n      result = LISP.cons(arguments[i], result)\n    return result\n  }\n  LISP['reverse!'] = (x) => {\n    let rev = LISP.nil\n    for (let ls = x; LISP['pair?'](ls); ) {\n      let d = ls.cdr\n      ls.cdr = rev\n      rev = ls\n      ls = d\n    }\n    return rev\n  }\n\n  LISP['number?'] = x => jsBoolToS(typeof x === 'number')\n  LISP['number->string'] = (x, n) => x.toString(n)\n  LISP['+'] = function() {\n    if (arguments.length == 0)\n      return 0\n    let result = arguments[0]\n    for (let i = 1; i < arguments.length; ++i)\n      result += arguments[i]\n    return result\n  }\n  LISP['*'] = function() {\n    if (arguments.length == 0)\n      return 1\n    let result = arguments[0]\n    for (let i = 1; i < arguments.length; ++i)\n      result *= arguments[i]\n    return result\n  }\n  LISP['-'] = function() {\n    if (arguments.length == 0)\n      return 0\n    let result = arguments[0]\n    if (arguments.length == 1)\n      return -result\n    for (let i = 1; i < arguments.length; ++i)\n      result -= arguments[i]\n    return result\n  }\n  LISP['/'] = function() {\n    if (arguments.length == 0)\n      return 1\n    let result = arguments[0]\n    if (arguments.length == 1)\n      return 1.0 / result\n    for (let i = 1; i < arguments.length; ++i)\n      result /= arguments[i]\n    return result\n  }\n  LISP['%'] = function() {\n    if (arguments.length == 0)\n      return 0\n    let result = arguments[0]\n    if (arguments.length == 1)\n      return result\n    for (let i = 1; i < arguments.length; ++i)\n      result %= arguments[i]\n    return result\n  }\n  LISP['<'] = function() {\n    if (arguments.length > 0) {\n      let value = arguments[0]\n      for (let i = 1; i < arguments.length; ++i) {\n        let target = arguments[i]\n        if (!(value < target))\n          return LISP.nil\n        value = target\n      }\n    }\n    return LISP.t\n  }\n  LISP['>'] = function() {\n    if (arguments.length > 0) {\n      let value = arguments[0]\n      for (let i = 1; i < arguments.length; ++i) {\n        let target = arguments[i]\n        if (!(value > target))\n          return LISP.nil\n        value = target\n      }\n    }\n    return LISP.t\n  }\n  LISP['<='] = function() {\n    if (arguments.length > 0) {\n      let value = arguments[0]\n      for (let i = 1; i < arguments.length; ++i) {\n        let target = arguments[i]\n        if (!(value <= target))\n          return LISP.nil\n        value = target\n      }\n    }\n    return LISP.t\n  }\n  LISP['>='] = function() {\n    if (arguments.length > 0) {\n      let value = arguments[0]\n      for (let i = 1; i < arguments.length; ++i) {\n        let target = arguments[i]\n        if (!(value >= target))\n          return LISP.nil\n        value = target\n      }\n    }\n    return LISP.t\n  }\n\n  // String.\n  LISP['string?'] = x => jsBoolToS(typeof x === 'string')\n  LISP['string=?'] = (x, y) => jsBoolToS(x === y)\n  LISP['string-append'] = function() {\n    return arguments2Array(arguments, 0).join('')\n  }\n  LISP['string-join'] = (list, separator) => {\n    if (list === LISP.nil)\n      return ''\n    return list.toArray().join(separator)\n  }\n  LISP['string-length'] = str => str.length\n  LISP['string-ref'] = (str, index) => str[index]\n  LISP.substring = (str, start, end) => str.slice(start, end)\n  LISP['string-scan'] = (str, item) => {\n    const index = str.indexOf(item)\n    return index >= 0 ? index : LISP.nil\n  }\n\n  LISP['char->integer'] = (char, index) => char.charCodeAt(index)\n\n  const kEscapeCharTable = {'\\\\': '\\\\\\\\', '\\t': '\\\\t', '\\n': '\\\\n', '\"': '\\\\\"'}\n  const inspectString = (str) => {\n    const f = (m) => {\n      if (m in kEscapeCharTable)\n        return kEscapeCharTable[m]\n      return '\\\\x' + ('0' + m.charCodeAt(0).toString(16)).slice(-2)\n    }\n    return '\"' + str.replace(/[\\x00-\\x1f\"\\\\]/g, f) + '\"'\n  }\n\n  LISP['x->string'] = makeString\n  LISP.print = (x) => {\n    LISP._output(makeString(x))\n    return x\n  }\n  LISP.puts = (x) => {\n    LISP._output(makeString(x))\n    if (typeof(process) !== 'undefined')\n      LISP._output('\\n')\n    return x\n  }\n  LISP.write = (x) => {\n    LISP._output(makeString(x, 10))  // 10 means true, and it is used as radix.\n    return x\n  }\n\n  LISP.apply = function(fn) {\n    let params = []\n    if (arguments.length > 1) {\n      for (let i = 1; i < arguments.length - 1; ++i)\n        params.push(arguments[i])\n      // Last argument for `apply` is expected as list (or nil).\n      const last = arguments[arguments.length - 1]\n      if (last !== LISP.nil)\n        params = params.concat(last.toArray())\n    }\n    return fn.apply(null, params)\n  }\n  LISP.JS = global\n\n  class HashTable {\n    constructor() {}\n\n    toString() {\n      let contents = ''\n      for (let k in this) {\n        if (!(this.hasOwnProperty(k)))\n          continue\n        if (contents.length > 0)\n          contents += ', '\n        contents += k + ':' + this[k]\n      }\n      return '#table<' + contents + '>'\n    }\n  }\n  LISP.HashTable = HashTable\n\n  // Hash table.\n  LISP['make-hash-table'] = () => new HashTable()\n  LISP['hash-table?'] = x => x instanceof HashTable\n  LISP['hash-table-exists?'] = (hash, x) => x in hash ? LISP.t : LISP.nil\n  LISP['hash-table-get'] = function(hash, x) {\n    if (x in hash)\n      return hash[x]\n    return (arguments.length >= 3) ? arguments[3 - 1] : LISP.nil\n  }\n  LISP['hash-table-put!'] = (hash, x, value) => hash[x] = value\n\n  // Vector.\n  LISP.vector = function() {\n    return arguments2Array(arguments, 0)\n  }\n  LISP['make-vector'] = (count, value) => {\n    if (value === undefined)\n      value = LISP.nil\n    const vector = new Array(count)\n    for (let i = 0; i < count; ++i)\n      vector[i] = value\n    return vector\n  }\n  LISP['vector?'] = x => jsBoolToS(x instanceof Array)\n  LISP['vector-length'] = vector => vector.length\n  LISP['vector-ref'] = (vector, index) => vector[index]\n  LISP['vector-set!'] = (vector, index, value) => vector[index] = value\n\n  // Regexp.\n  LISP['regexp?'] = x => jsBoolToS(x instanceof RegExp)\n  LISP.rxmatch = (re, str) => jsBoolToS(re.exec(str))\n  LISP['regexp-replace-all'] = (re, str, fn) => {\n    if (!re.global) {\n      const s = re.toString()\n      const i = s.lastIndexOf('/')\n      re = new RegExp(s.slice(1, i), s.slice(i + 1) + 'g')\n    }\n    return str.replace(re, (match) => {\n      return fn(() => {  // TODO: handle arguments.\n        return match\n      })\n    })\n  }\n  LISP['regexp->string'] = (x) => {\n    const s = x.toString()\n    return s.slice(1, s.length - 1)\n  }\n\n  // Stream.\n  class Stream {\n    constructor() {\n      this.str = ''\n      this.lineNo = 0\n    }\n\n    close() {}\n    peek() {\n      const result = this.fetch()\n      if (result == null)\n        return result\n      return this.str[0]\n    }\n    getc() {\n      const c = this.peek()\n      if (c == null)\n        return c\n      this.str = this.str.slice(1)\n      return c\n    }\n    match(regexp, keep) {\n      const result = this.fetch()\n      if (result == null)\n        return result\n\n      const m = this.str.match(regexp)\n      if (m && !keep)\n        this.str = RegExp.rightContext\n      return m\n    }\n    eof() {\n      return this.str == null\n    }\n    getLine() {\n      const result = this.str || this.readLine()\n      this.str = ''\n      return result\n    }\n    fetch() {\n      if (this.str == null)\n        return null\n\n      if (this.str === '') {\n        if ((this.str = this.readLine()) == null)\n          return undefined\n        ++this.lineNo\n      }\n      return this.str\n    }\n  }\n\n  class StrStream extends Stream {\n    constructor(str) {\n      super()\n      this.str = str\n      this.lineNo = 1\n    }\n\n    readLine() {\n      return null\n    }\n  }\n  LISP.StrStream = StrStream\n\n  // Reader.\n  LISP.NoCloseParenException = function() {}\n\n  const kDelimitors = '\\\\s(){}\\\\[\\\\]\\'`,;#\"'\n  const kReSingleDot = RegExp('^\\\\.(?=[' + kDelimitors + '])')\n  const kReSymbolOrNumber = RegExp('^([^' + kDelimitors + ']+)')\n  const kReadUnescapeTable = {\n    't': '\\t',\n    'n': '\\n',\n  }\n\n  const readTable = {}\n\n  class Reader {\n    static read(stream) {\n      do {\n        if (stream.eof())\n          return null\n      } while (stream.match(/^\\s+/))\n\n      const c = stream.peek()\n      if (c in readTable)\n        return readTable[c](stream, stream.getc())\n\n      let m\n      if (stream.match(/^\\(/))  // Left paren '('.\n        return Reader.readList(stream)\n      if (stream.match(/^;[^\\n]*\\n?/))  // Line comment.\n        return Reader.read(stream)\n      if (m = stream.match(/^\"((\\\\.|[^\"\\\\])*)\"/))  // string.\n        return Reader.unescape(m[1])\n      if (stream.match(/^#\\(/))  // vector.\n        return Reader.readVector(stream)\n      if (m = stream.match(/^#\\/([^\\/]*)\\//))  // regexp TODO: Implement properly.\n        return new RegExp(m[1])\n      if (stream.match(/^#\\|(.|[\\n\\r])*?\\|#/))  // Block comment.\n        return Reader.read(stream)\n      if (stream.match(kReSingleDot, true))  // Single dot.\n        return undefined\n      if (m = stream.match(kReSymbolOrNumber))  // Symbol or number.\n        return Reader.readSymbolOrNumber(m[1])\n      return undefined\n    }\n\n    static readSymbolOrNumber(str) {\n      if (str === 'nil')\n        return LISP.nil\n      if (str === 't')\n        return LISP.t\n      if (str[0] === ':')\n        return LISP['make-keyword'](str.slice(1))\n      if (str.match(/^([+\\-]?[0-9]+(\\.[0-9]*)?)$/))  // Number.\n        return parseFloat(str)\n      return LISP.intern(str)\n    }\n\n    static readList(stream) {\n      let result = LISP.nil\n      for (;;) {\n        const x = Reader.read(stream)\n        if (x == null)\n          break\n        result = new Cons(x, result, stream.lineNo, stream.path)\n      }\n\n      if (stream.match(/^\\s*\\)/)) {  // Close paren.\n        return LISP['reverse!'](result)\n      }\n      if (stream.match(kReSingleDot)) {  // Dot.\n        const last = Reader.read(stream)\n        if (last != null) {\n          if (stream.match(/^\\s*\\)/)) {  // Close paren.\n            const reversed = LISP['reverse!'](result)\n            result.cdr = last\n            return reversed\n          }\n        }\n      }\n      // Error\n      throw new LISP.NoCloseParenException()\n    }\n\n    static readVector(stream) {\n      const result = []\n      for (;;) {\n        const x = Reader.read(stream)\n        if (x !== undefined) {\n          result.push(x)\n          continue\n        }\n\n        if (stream.match(/^\\s*\\)/)) {  // Close paren.\n          return result\n        }\n        // Error\n        throw new LISP.NoCloseParenException()\n      }\n    }\n\n    static unescape(str) {\n      return str.replace(/\\\\(x([0-9a-fA-F]{2})|(.))/g, (_1, _2, hex, c) => {\n        if (hex)\n          return String.fromCharCode(parseInt(hex, 16))\n        if (c in kReadUnescapeTable)\n          return kReadUnescapeTable[c]\n        return c\n      })\n    }\n  }\n\n  LISP['set-macro-character'] = (c, fn) => {\n    readTable[c] = fn\n  }\n\n  LISP['set-macro-character']('\\'', (stream, c) => {\n    return LISP.list(LISP.intern('quote'), Reader.read(stream))\n  })\n  LISP['set-macro-character']('`', (stream, c) => {\n    return LISP.list(LISP.intern('quasiquote'), Reader.read(stream))\n  })\n  LISP['set-macro-character'](',', (stream, c) => {\n    const c2 = stream.peek()\n    let keyword = 'unquote'\n    if (c2 == '@') {\n      keyword = 'unquote-splicing'\n      stream.getc()\n    }\n    return LISP.list(LISP.intern(keyword), Reader.read(stream))\n  })\n\n  LISP.read = stream => Reader.read(stream || LISP['*stdin*'])\n\n  LISP['read-from-string'] = str => Reader.read(new StrStream(str))\n\n  LISP['read-line'] = (stream) => {\n    return (stream || LISP['*stdin*']).getLine()\n  }\n\n  // For node JS.\n  if (typeof process !== 'undefined') {\n    const fs = require('fs')\n\n    const BUFFER_SIZE = 4096\n    const buffer = new Buffer(BUFFER_SIZE)\n    class FileStream extends Stream {\n      constructor(fd, path) {\n        super()\n        this.fd = fd\n        this.path = path\n        this.lines = []\n        this.index = 0\n      }\n\n      close() {\n        if (this.fd == null)\n          return\n        fs.closeSync(this.fd)\n        this.fd = null\n        this.lines.length = this.index = 0\n        this.str = null\n        this.chomped = false\n      }\n      readLine() {\n        for (;;) {\n          let left = ''\n          if (this.index < this.lines.length) {\n            if (this.index < this.lines.length - 1 || !this.chomped)\n              return this.lines[this.index++]\n            if (this.chomped)\n              left = this.lines[this.index]\n          }\n\n          if (this.fd == null)\n            return LISP.nil\n          const n = fs.readSync(this.fd, buffer, 0, BUFFER_SIZE)\n          if (n <= 0)\n            return null\n          let string = left + buffer.slice(0, n).toString()\n          this.chomped = false\n          if (string.length > 0) {\n            if (string[string.length - 1] != '\\n')\n              this.chomped = true\n            else\n              // Remove last '\\n' to avoid last empty line.\n              string = string.slice(0, string.length - 1)\n          }\n          this.lines = string.split('\\n')\n          this.index = 0\n        }\n      }\n    }\n    LISP.FileStream = FileStream\n\n    LISP['*stdin*'] = new LISP.FileStream(process.stdin.fd, '*stdin*')\n    LISP['*stdout*'] = new LISP.FileStream(process.stdout.fd, '*stdout*')\n    LISP['*stderr*'] = new LISP.FileStream(process.stderr.fd, '*stderr*')\n\n    LISP.open = (path, flag) => {\n      try {\n        const fd = fs.openSync(path, flag || 'r')\n        return new LISP.FileStream(fd, path)\n      } catch (e) {\n        return LISP.nil\n      }\n    }\n\n    LISP.close = (stream) => {\n      stream.close()\n      return stream\n    }\n\n    LISP.load = (fileName) => {\n      const stream = LISP.open(fileName)\n      if (!stream) {\n        return LISP.error('Cannot open [' + fileName + ']')\n      }\n\n      if (stream.match(/^#!/, true))\n        stream.getLine()  // Skip Shebang.\n\n      let result\n      for (;;) {\n        const s = LISP.read(stream)\n        if (s == null)\n          break\n        result = LISP.eval(s)\n      }\n      LISP.close(stream)\n      return result\n    }\n\n    // System\n    LISP.exit = (code) => process.exit(code)\n\n    LISP.jsrequire = require\n  }\n\n  /*==== EMBED COMPILED CODE HERE ====*/\nLISP[\"register-macro\"](LISP.intern(\"defmacro\"), (function(name, params){var body = LISP._getRestArgs(arguments, 2); return (LISP.list(LISP.intern(\"register-macro\"), LISP.list(LISP.intern(\"quote\"), name), LISP[\"list*\"](LISP.intern(\"lambda\"), params, body)));}));\nLISP[\"register-macro\"](LISP.intern(\"defun\"), (function(name, params){var body = LISP._getRestArgs(arguments, 2); return (LISP.list(LISP.intern(\"def\"), name, LISP[\"list*\"](LISP.intern(\"lambda\"), params, body)));}));\nLISP[\"register-macro\"](LISP.intern(\"let\"), (function(pairs){var body = LISP._getRestArgs(arguments, 1); return ((LISP.isTrue(LISP[\"symbol?\"](pairs)) ? ((function() { var __2 = LISP.list(LISP.nil); return (function(name, pairs, body){return (LISP[\"list*\"](LISP.list(LISP.intern(\"lambda\"), LISP.list(name), LISP.list(LISP.intern(\"set!\"), name, LISP[\"list*\"](LISP.intern(\"lambda\"), LISP.map(LISP.car, pairs), body)), LISP[\"list*\"](name, LISP.map(LISP.cadr, pairs))), __2));}); })()(pairs, LISP.car(body), LISP.cdr(body))) : (LISP[\"list*\"](LISP[\"list*\"](LISP.intern(\"lambda\"), LISP.map(LISP.car, pairs), body), LISP.map(LISP.cadr, pairs)))));}));\nLISP[\"register-macro\"](LISP.intern(\"let1\"), (function(name, value){var body = LISP._getRestArgs(arguments, 2); return (LISP[\"list*\"](LISP.intern(\"let\"), LISP.list(LISP.list(name, value)), body));}));\nLISP[\"register-macro\"](LISP.intern(\"let*\"), (function(pairs){var body = LISP._getRestArgs(arguments, 1); return ((LISP.isTrue(LISP[\"null?\"](pairs)) ? (LISP[\"list*\"](LISP.intern(\"do\"), body)) : (LISP.list(LISP.intern(\"let1\"), LISP.caar(pairs), LISP.cadar(pairs), LISP[\"list*\"](LISP.intern(\"let*\"), LISP.cdr(pairs), body)))));}));\nLISP[\"register-macro\"](LISP.intern(\"when\"), (function(pred){var body = LISP._getRestArgs(arguments, 1); return (LISP.list(LISP.intern(\"if\"), pred, LISP[\"list*\"](LISP.intern(\"do\"), body)));}));\nLISP[\"register-macro\"](LISP.intern(\"unless\"), (function(pred){var body = LISP._getRestArgs(arguments, 1); return (LISP.list(LISP.intern(\"if\"), pred, LISP.nil, LISP[\"list*\"](LISP.intern(\"do\"), body)));}));\nLISP[\"register-macro\"](LISP.intern(\"cond\"), (function(){var clauses = LISP._getRestArgs(arguments, 0); return ((LISP.isTrue(LISP[\"null?\"](clauses)) ? (LISP.nil) : ((function(clause, rest){return ((LISP.isTrue(LISP[\"eq?\"](LISP.car(clause), LISP.t)) ? (LISP[\"list*\"](LISP.intern(\"do\"), LISP.cdr(clause))) : ((LISP.isTrue(LISP[\"null?\"](LISP.cdr(clause))) ? ((function(g){return (LISP.list(LISP.intern(\"let\"), LISP.list(LISP.list(g, LISP.car(clause))), LISP.list(LISP.intern(\"if\"), g, g, LISP[\"list*\"](LISP.intern(\"cond\"), rest))));})(LISP.gensym())) : ((LISP.isTrue(LISP[\"eq?\"](LISP.cadr(clause), LISP.intern(\"=>\"))) ? ((function(g){return (LISP.list(LISP.intern(\"let\"), LISP.list(LISP.list(g, LISP.car(clause))), LISP.list(LISP.intern(\"if\"), g, LISP.list(LISP.caddr(clause), g), LISP[\"list*\"](LISP.intern(\"cond\"), rest))));})(LISP.gensym())) : (LISP.list(LISP.intern(\"if\"), LISP.car(clause), LISP[\"list*\"](LISP.intern(\"do\"), LISP.cdr(clause)), LISP[\"list*\"](LISP.intern(\"cond\"), rest)))))))));})(LISP.car(clauses), LISP.cdr(clauses)))));}));\nLISP[\"register-macro\"](LISP.intern(\"case\"), (function(x){var clauses = LISP._getRestArgs(arguments, 1); return ((function(value){return (LISP.list(LISP.intern(\"let1\"), value, x, LISP[\"list*\"](LISP.intern(\"cond\"), LISP.map((function(clause){return ((LISP.isTrue(LISP[\"eq?\"](LISP.car(clause), LISP.t)) ? (clause) : ((LISP.isTrue(LISP[\"null?\"](LISP.cdar(clause))) ? (LISP[\"list*\"](LISP.list(LISP.intern(\"eq?\"), value, LISP.list(LISP.intern(\"quote\"), LISP.caar(clause))), LISP.cdr(clause))) : (LISP[\"list*\"](LISP.list(LISP.intern(\"member\"), value, LISP.list(LISP.intern(\"quote\"), LISP.car(clause))), LISP.cdr(clause)))))));}), clauses))));})(LISP.gensym()));}));\nLISP[\"register-macro\"](LISP.intern(\"and\"), (function() { var __3 = LISP.list(LISP.nil); return (function(){var args = LISP._getRestArgs(arguments, 0); return ((LISP.isTrue(LISP[\"null?\"](args)) ? (LISP.t) : ((LISP.isTrue(LISP[\"null?\"](LISP.cdr(args))) ? (LISP.car(args)) : (LISP[\"list*\"](LISP.intern(\"if\"), LISP.car(args), LISP[\"list*\"](LISP.intern(\"and\"), LISP.cdr(args)), __3))))));}); })());\nLISP[\"register-macro\"](LISP.intern(\"or\"), (function(){var args = LISP._getRestArgs(arguments, 0); return ((LISP.isTrue(LISP[\"null?\"](LISP.cdr(args))) ? (LISP.car(args)) : ((function(g){return (LISP.list(LISP.intern(\"let1\"), g, LISP.car(args), LISP.list(LISP.intern(\"if\"), g, g, LISP[\"list*\"](LISP.intern(\"or\"), LISP.cdr(args)))));})(LISP.gensym()))));}));\nLISP[\"register-macro\"](LISP.intern(\"do\"), (function(){var body = LISP._getRestArgs(arguments, 0); return ((LISP.isTrue(LISP[\"null?\"](body)) ? (LISP.nil) : ((LISP.isTrue(LISP[\"null?\"](LISP.cdr(body))) ? (LISP.car(body)) : (LISP[\"list*\"](LISP.intern(\"let\"), LISP.nil, body))))));}));\nLISP[\"register-macro\"](LISP.intern(\"aif\"), (function(expr, thn){var els = LISP._getRestArgs(arguments, 2); return (LISP.list(LISP.intern(\"let1\"), LISP.intern(\"it\"), expr, LISP[\"list*\"](LISP.intern(\"if\"), LISP.intern(\"it\"), thn, els)));}));\nLISP[\"register-macro\"](LISP.intern(\"awhen\"), (function(expr){var body = LISP._getRestArgs(arguments, 1); return (LISP.list(LISP.intern(\"aif\"), expr, LISP[\"list*\"](LISP.intern(\"do\"), body)));}));\nLISP[\"register-macro\"](LISP.intern(\"awhile\"), (function(expr){var body = LISP._getRestArgs(arguments, 1); return ((function(loop){return (LISP.list(LISP.intern(\"let\"), loop, LISP.nil, LISP.list(LISP.intern(\"let1\"), LISP.intern(\"it\"), expr, LISP[\"list*\"](LISP.intern(\"when\"), LISP.intern(\"it\"), LISP.append(body, LISP.list(LISP.list(loop)))))));})(LISP.gensym()));}));\nLISP[\"null?\"] = (function(x){return (LISP[\"eq?\"](x, LISP.nil));});\nLISP.not = (function(x){return (LISP[\"eq?\"](x, LISP.nil));});\nLISP.caar = (function(x){return (LISP.car(LISP.car(x)));});\nLISP.cadr = (function(x){return (LISP.car(LISP.cdr(x)));});\nLISP.cdar = (function(x){return (LISP.cdr(LISP.car(x)));});\nLISP.cddr = (function(x){return (LISP.cdr(LISP.cdr(x)));});\nLISP.cadar = (function(x){return (LISP.cadr(LISP.car(x)));});\nLISP.caddr = (function(x){return (LISP.car(LISP.cddr(x)));});\nLISP.cdddr = (function(x){return (LISP.cdr(LISP.cddr(x)));});\nLISP[\"equal?\"] = (function(x, y){return ((LISP.isTrue(LISP[\"eq?\"](x, y)) ? (LISP.t) : ((function(xtype){return ((LISP.isTrue(LISP[\"eq?\"](xtype, LISP.type(y))) ? ((function(__4){return ((LISP.isTrue(LISP[\"eq?\"](__4, LISP.intern(\"pair\"))) ? ((LISP.isTrue(LISP[\"equal?\"](LISP.car(x), LISP.car(y))) ? (LISP[\"equal?\"](LISP.cdr(x), LISP.cdr(y))) : (LISP.nil))) : ((LISP.isTrue(LISP[\"eq?\"](__4, LISP.intern(\"vector\"))) ? ((function(n){return ((LISP.isTrue(LISP[\"eq?\"](n, LISP[\"vector-length\"](y))) ? ((function(loop){return (loop = (function(i){return ((function(__5){return ((LISP.isTrue(__5) ? (__5) : ((LISP.isTrue(LISP[\"equal?\"](LISP[\"vector-ref\"](x, i), LISP[\"vector-ref\"](y, i))) ? (loop((i + 1))) : (LISP.nil)))));})(LISP[\">=\"](i, n)));}), loop(0));})(LISP.nil)) : (LISP.nil)));})(LISP[\"vector-length\"](x))) : (LISP.nil)))));})(xtype)) : (LISP.nil)));})(LISP.type(x)))));});\nLISP.length = (function(ls){return ((function(loop){return (loop = (function(ls, acc){return ((LISP.isTrue(LISP[\"pair?\"](ls)) ? (loop(LISP.cdr(ls), (acc + 1))) : (acc)));}), loop(ls, 0));})(LISP.nil));});\nLISP[\"last-pair\"] = (function(ls){return ((LISP.isTrue(LISP[\"pair?\"](LISP.cdr(ls))) ? (LISP[\"last-pair\"](LISP.cdr(ls))) : (ls)));});\nLISP.member = (function(x, ls){return ((LISP.isTrue(LISP[\"null?\"](ls)) ? (LISP.nil) : ((LISP.isTrue(LISP[\"eq?\"](x, LISP.car(ls))) ? (ls) : (LISP.member(x, LISP.cdr(ls)))))));});\nLISP.assoc = (function(x, ls){return ((LISP.isTrue(LISP[\"null?\"](ls)) ? (LISP.nil) : ((LISP.isTrue(LISP[\"eq?\"](x, LISP.caar(ls))) ? (LISP.car(ls)) : (LISP.assoc(x, LISP.cdr(ls)))))));});\nLISP.acons = (function(key, datum, alist){return (LISP.cons(LISP.cons(key, datum), alist));});\nLISP.map = (function(f, ls){return ((LISP.isTrue(LISP[\"null?\"](ls)) ? (LISP.nil) : (LISP.cons(f(LISP.car(ls)), LISP.map(f, LISP.cdr(ls))))));});\nLISP.append = (function(ls){var rest = LISP._getRestArgs(arguments, 1); return ((LISP.isTrue(LISP[\"null?\"](rest)) ? (ls) : ((LISP.isTrue(LISP[\"null?\"](ls)) ? (LISP.apply(LISP.append, rest)) : (LISP.cons(LISP.car(ls), LISP.apply(LISP.append, LISP.cdr(ls), rest)))))));});\nLISP.reverse = (function(ls){return ((function(loop){return (loop = (function(ls, acc){return ((LISP.isTrue(LISP[\"pair?\"](ls)) ? (loop(LISP.cdr(ls), LISP.cons(LISP.car(ls), acc))) : (acc)));}), loop(ls, LISP.nil));})(LISP.nil));});\nLISP[\"list*\"] = (function(){var args = LISP._getRestArgs(arguments, 0); return ((LISP.isTrue(LISP[\"null?\"](args)) ? (LISP.nil) : ((LISP.isTrue(LISP[\"null?\"](LISP.cdr(args))) ? (LISP.car(args)) : ((function(loop){return (loop = (function(p, q){return ((LISP.isTrue(LISP[\"null?\"](LISP.cdr(q))) ? ((function(){return (LISP[\"set-cdr!\"](p, LISP.car(q)), args);})()) : (loop(q, LISP.cdr(q)))));}), loop(args, LISP.cdr(args)));})(LISP.nil))))));});\nLISP[\"last-pair\"] = (function(ls){return ((LISP.isTrue(LISP[\"pair?\"](LISP.cdr(ls))) ? (LISP[\"last-pair\"](LISP.cdr(ls))) : (ls)));});\nLISP[\"proper-list?\"] = (function(ls){return ((LISP.isTrue(LISP[\"pair?\"](ls)) ? (LISP[\"null?\"](LISP.cdr(LISP[\"last-pair\"](ls)))) : (LISP.nil)));});\nLISP[\"dotted->proper\"] = (function(ls){return ((LISP.isTrue(LISP[\"pair?\"](ls)) ? ((LISP.isTrue(LISP[\"proper-list?\"](ls)) ? (ls) : ((function(dot, rev){return ((function(dup){return (LISP[\"set-cdr!\"](rev, LISP.list(dot)), dup);})(LISP[\"reverse!\"](rev)));})(LISP.cdr(LISP[\"last-pair\"](ls)), LISP.reverse(ls))))) : (LISP.list(ls))));});\nLISP[\"vector->list\"] = (function(vect){return ((function(loop){return (loop = (function(i, acc){return ((LISP.isTrue(LISP[\"<\"](i, 0)) ? (acc) : (loop((i - 1), LISP.cons(LISP[\"vector-ref\"](vect, i), acc)))));}), loop((LISP[\"vector-length\"](vect) - 1), LISP.nil));})(LISP.nil));});\nLISP[\"position-if\"] = (function(pred, seq){return ((function(loop){return (loop = (function(p, i){return ((LISP.isTrue(p) ? ((LISP.isTrue(pred(LISP.car(p))) ? (i) : (loop(LISP.cdr(p), (i + 1))))) : (LISP.nil)));}), loop(seq, 0));})(LISP.nil));});\nLISP.take = (function(n, ls){return ((function(loop){return (loop = (function(n, ls, acc){return ((LISP.isTrue((function(__6){return ((LISP.isTrue(__6) ? (__6) : (LISP[\"null?\"](ls))));})(LISP[\"<=\"](n, 0))) ? (LISP[\"reverse!\"](acc)) : (loop((n - 1), LISP.cdr(ls), LISP.cons(LISP.car(ls), acc)))));}), loop(n, ls, LISP.nil));})(LISP.nil));});\nLISP.drop = (function(n, ls){return ((LISP.isTrue((function(__7){return ((LISP.isTrue(__7) ? (__7) : (LISP[\"null?\"](ls))));})(LISP[\"<=\"](n, 0))) ? (ls) : (LISP.drop((n - 1), LISP.cdr(ls)))));});\nLISP.elt = (function(n, ls){return (LISP.car(LISP.drop(n, ls)));});\nLISP[\"remove-if\"] = (function(test, seq){return ((function(loop){return (loop = (function(seq, acc){return ((LISP.isTrue(LISP[\"null?\"](seq)) ? (LISP[\"reverse!\"](acc)) : (loop(LISP.cdr(seq), (LISP.isTrue(test(LISP.car(seq))) ? (acc) : (LISP.cons(LISP.car(seq), acc)))))));}), loop(seq, LISP.nil));})(LISP.nil));});\nLISP[\"register-macro\"](LISP.intern(\"dotimes\"), (function(params){var body = LISP._getRestArgs(arguments, 1); return ((function() { var __8 = LISP.list(0), __9 = LISP.list(1); return (function(i, limit, loop){return (LISP.list(LISP.intern(\"let1\"), limit, LISP.cadr(params), LISP.list(LISP.intern(\"let\"), loop, LISP.list(LISP[\"list*\"](i, __8)), LISP.list(LISP.intern(\"if\"), LISP.list(LISP.intern(\"<\"), i, limit), LISP[\"list*\"](LISP.intern(\"do\"), LISP.append(body, LISP.list(LISP.list(loop, LISP[\"list*\"](LISP.intern(\"+\"), i, __9))))), LISP.caddr(params)))));}); })()(LISP.car(params), LISP.gensym(), LISP.gensym()));}));\nLISP[\"register-macro\"](LISP.intern(\"dolist\"), (function(pair){var body = LISP._getRestArgs(arguments, 1); return ((function(i, loop, ls){return (LISP.list(LISP.intern(\"let\"), loop, LISP.list(LISP.list(ls, LISP.cadr(pair))), LISP.list(LISP.intern(\"let1\"), i, LISP.list(LISP.intern(\"car\"), ls), LISP[\"list*\"](LISP.intern(\"when\"), i, LISP.append(body, LISP.list(LISP.list(loop, LISP.list(LISP.intern(\"cdr\"), ls))))))));})(LISP.car(pair), LISP.gensym(), LISP.gensym()));}));\nLISP[\"register-macro\"](LISP.intern(\"labels\"), (function(lss){var body = LISP._getRestArgs(arguments, 1); return (LISP[\"list*\"](LISP.intern(\"let\"), LISP.map((function(ls){return (LISP.car(ls));}), lss), LISP.append(LISP.map((function(ls){return (LISP.list(LISP.intern(\"set!\"), LISP.car(ls), LISP[\"list*\"](LISP.intern(\"lambda\"), LISP.cdr(ls))));}), lss), body)));}));\nLISP.nreconc = (function(ls, tail){return ((function(top){return (LISP[\"set-cdr!\"](ls, tail), top);})(LISP[\"reverse!\"](ls)));});\nLISP.any = (function(f, ls){return ((LISP.isTrue(LISP[\"null?\"](ls)) ? (LISP.nil) : ((LISP.isTrue(f(LISP.car(ls))) ? (LISP.t) : (LISP.any(f, LISP.cdr(ls)))))));});\nLISP.every = (function(f, ls){return ((LISP.isTrue(LISP[\"null?\"](ls)) ? (LISP.t) : ((LISP.isTrue(f(LISP.car(ls))) ? (LISP.every(f, LISP.cdr(ls))) : (LISP.nil)))));});\nLISP[\"*bq-clobberable*\"] = LISP.gensym();\nLISP[\"*bq-quote-nil*\"] = LISP.list(LISP.intern(\"quote\"), LISP.nil);\nLISP[\"register-macro\"](LISP.intern(\"quasiquote\"), (function(x){return (LISP[\"bq-completely-process\"](x));}));\nLISP[\"bq-completely-process\"] = (function(x){return (LISP[\"bq-simplify\"](LISP[\"bq-process\"](x)));});\nLISP[\"bq-process\"] = (function(x){return ((LISP.isTrue(LISP.not(LISP[\"pair?\"](x))) ? (LISP.list(LISP.intern(\"quote\"), x)) : ((LISP.isTrue(LISP[\"eq?\"](LISP.car(x), LISP.intern(\"quasiquote\"))) ? (LISP[\"bq-process\"](LISP[\"bq-completely-process\"](LISP.cadr(x)))) : ((LISP.isTrue(LISP[\"eq?\"](LISP.car(x), LISP.intern(\"unquote\"))) ? (LISP.cadr(x)) : ((LISP.isTrue(LISP[\"eq?\"](LISP.car(x), LISP.intern(\"unquote-splicing\"))) ? (LISP.error(\",@~S after `\", LISP.cadr(x))) : ((LISP.isTrue(LISP[\"eq?\"](LISP.car(x), LISP.intern(\"unquote-dot\"))) ? (LISP.error(\",.~S after `\", LISP.cadr(x))) : ((function(loop){return (loop = (function(p, q){return ((LISP.isTrue(LISP.not(LISP[\"pair?\"](p))) ? (LISP.cons(LISP.intern(\"append\"), LISP.nreconc(q, LISP.list(LISP.list(LISP.intern(\"quote\"), p))))) : ((LISP.isTrue(LISP[\"eq?\"](LISP.car(p), LISP.intern(\"unquote\"))) ? ((function(){return ((LISP.isTrue(LISP[\"null?\"](LISP.cddr(p))) ? (LISP.nil) : (LISP.error(\"Malformed ,~S\", p))), LISP.cons(LISP.intern(\"append\"), LISP.nreconc(q, LISP.list(LISP.cadr(p)))));})()) : ((function(){return ((LISP.isTrue(LISP[\"eq?\"](LISP.car(p), LISP.intern(\"unquote-splicing\"))) ? (LISP.error(\"Dotted ,@~S\", p)) : (LISP.nil)), (LISP.isTrue(LISP[\"eq?\"](LISP.car(p), LISP.intern(\"unquote-dot\"))) ? (LISP.error(\"Dotted ,.~S\", p)) : (LISP.nil)), loop(LISP.cdr(p), LISP.cons(LISP.bracket(LISP.car(p)), q)));})())))));}), loop(x, LISP.nil));})(LISP.nil))))))))))));});\nLISP.bracket = (function(x){return ((LISP.isTrue(LISP.not(LISP[\"pair?\"](x))) ? (LISP.list(LISP.intern(\"list\"), LISP[\"bq-process\"](x))) : ((LISP.isTrue(LISP[\"eq?\"](LISP.car(x), LISP.intern(\"unquote\"))) ? (LISP.list(LISP.intern(\"list\"), LISP.cadr(x))) : ((LISP.isTrue(LISP[\"eq?\"](LISP.car(x), LISP.intern(\"unquote-splicing\"))) ? (LISP.cadr(x)) : ((LISP.isTrue(LISP[\"eq?\"](LISP.car(x), LISP.intern(\"unquote-dot\"))) ? (LISP.list(LISP[\"*bq-clobberable*\"], LISP.cadr(x))) : (LISP.list(LISP.intern(\"list\"), LISP[\"bq-process\"](x)))))))))));});\nLISP.maptree = (function(fn, x){return ((LISP.isTrue(LISP.not(LISP[\"pair?\"](x))) ? (fn(x)) : ((function(a, d){return ((LISP.isTrue((LISP.isTrue(LISP[\"equal?\"](a, LISP.car(x))) ? (LISP[\"equal?\"](d, LISP.cdr(x))) : (LISP.nil))) ? (x) : (LISP.cons(a, d))));})(fn(LISP.car(x)), LISP.maptree(fn, LISP.cdr(x))))));});\nLISP[\"bq-splicing-frob\"] = (function(x){return ((LISP.isTrue(LISP[\"pair?\"](x)) ? ((function(__2){return ((LISP.isTrue(__2) ? (__2) : (LISP[\"eq?\"](LISP.car(x), LISP.intern(\"unquote-dot\")))));})(LISP[\"eq?\"](LISP.car(x), LISP.intern(\"unquote-splicing\")))) : (LISP.nil)));});\nLISP[\"bq-frob\"] = (function(x){return ((LISP.isTrue(LISP[\"pair?\"](x)) ? ((function(__3){return ((LISP.isTrue(__3) ? (__3) : ((function(__4){return ((LISP.isTrue(__4) ? (__4) : (LISP[\"eq?\"](LISP.car(x), LISP.intern(\"unquote-dot\")))));})(LISP[\"eq?\"](LISP.car(x), LISP.intern(\"unquote-splicing\"))))));})(LISP[\"eq?\"](LISP.car(x), LISP.intern(\"unquote\")))) : (LISP.nil)));});\nLISP[\"bq-simplify\"] = (function(x){return ((LISP.isTrue(LISP[\"pair?\"](x)) ? ((function(x){return ((LISP.isTrue(LISP.not(LISP[\"eq?\"](LISP.car(x), LISP.intern(\"append\")))) ? (x) : (LISP[\"bq-simplify-args\"](x))));})((LISP.isTrue(LISP[\"eq?\"](LISP.car(x), LISP.intern(\"quote\"))) ? (x) : (LISP.maptree(LISP[\"bq-simplify\"], x))))) : (x)));});\nLISP[\"bq-simplify-args\"] = (function(x){return ((function(loop){return (loop = (function(args, result){return ((LISP.isTrue(LISP.not(LISP[\"null?\"](args))) ? (loop(LISP.cdr(args), (LISP.isTrue(LISP.not(LISP[\"pair?\"](LISP.car(args)))) ? (LISP[\"bq-attach-append\"](LISP.intern(\"append\"), LISP.car(args), result)) : ((LISP.isTrue((LISP.isTrue(LISP[\"eq?\"](LISP.caar(args), LISP.intern(\"list\"))) ? (LISP.not(LISP.any(LISP[\"bq-splicing-frob\"], LISP.cdar(args)))) : (LISP.nil))) ? (LISP[\"bq-attach-conses\"](LISP.cdar(args), result)) : ((LISP.isTrue((LISP.isTrue(LISP[\"eq?\"](LISP.caar(args), LISP.intern(\"list*\"))) ? (LISP.not(LISP.any(LISP[\"bq-splicing-frob\"], LISP.cdar(args)))) : (LISP.nil))) ? (LISP[\"bq-attach-conses\"](LISP.reverse(LISP.cdr(LISP.reverse(LISP.cdar(args)))), LISP[\"bq-attach-append\"](LISP.intern(\"append\"), LISP.car(LISP.last(LISP.car(args))), result))) : ((LISP.isTrue((LISP.isTrue(LISP[\"eq?\"](LISP.caar(args), LISP.intern(\"quote\"))) ? ((LISP.isTrue(LISP[\"pair?\"](LISP.cadar(args))) ? ((LISP.isTrue(LISP.not(LISP[\"bq-frob\"](LISP.cadar(args)))) ? (LISP.not(LISP.cddar(args))) : (LISP.nil))) : (LISP.nil))) : (LISP.nil))) ? (LISP[\"bq-attach-conses\"](LISP.list(LISP.list(LISP.intern(\"quote\"), LISP.caadar(args))), result)) : ((LISP.isTrue(LISP[\"eq?\"](LISP.caar(args), LISP[\"*bq-clobberable*\"])) ? (LISP[\"bq-attach-append\"](LISP.intern(\"append!\"), LISP.cadar(args), result)) : (LISP[\"bq-attach-append\"](LISP.intern(\"append\"), LISP.car(args), result))))))))))))) : (result)));}), loop(LISP.reverse(LISP.cdr(x)), LISP.nil));})(LISP.nil));});\nLISP[\"null-or-quoted\"] = (function(x){return ((function(__5){return ((LISP.isTrue(__5) ? (__5) : ((LISP.isTrue(LISP[\"pair?\"](x)) ? (LISP[\"eq?\"](LISP.car(x), LISP.intern(\"quote\"))) : (LISP.nil)))));})(LISP[\"null?\"](x)));});\nLISP[\"bq-attach-append\"] = (function(op, item, result){return ((LISP.isTrue((LISP.isTrue(LISP[\"null-or-quoted\"](item)) ? (LISP[\"null-or-quoted\"](result)) : (LISP.nil))) ? (LISP.list(LISP.intern(\"quote\"), LISP.append(LISP.cadr(item), LISP.cadr(result)))) : ((LISP.isTrue((function(__6){return ((LISP.isTrue(__6) ? (__6) : (LISP[\"equal?\"](result, LISP[\"*bq-quote-nil*\"]))));})(LISP[\"null?\"](result))) ? ((LISP.isTrue(LISP[\"bq-splicing-frob\"](item)) ? (LISP.list(op, item)) : (item))) : ((LISP.isTrue((LISP.isTrue(LISP[\"pair?\"](result)) ? (LISP[\"eq?\"](LISP.car(result), op)) : (LISP.nil))) ? (LISP[\"list*\"](LISP.car(result), item, LISP.cdr(result))) : (LISP.list(op, item, result))))))));});\nLISP[\"bq-attach-conses\"] = (function(items, result){return ((LISP.isTrue((LISP.isTrue(LISP.every(LISP[\"null-or-quoted\"], items)) ? (LISP[\"null-or-quoted\"](result)) : (LISP.nil))) ? (LISP.list(LISP.intern(\"quote\"), LISP.append(LISP.map(LISP.cadr, items), LISP.cadr(result)))) : ((LISP.isTrue((function(__7){return ((LISP.isTrue(__7) ? (__7) : (LISP[\"equal?\"](result, LISP[\"*bq-quote-nil*\"]))));})(LISP[\"null?\"](result))) ? (LISP.cons(LISP.intern(\"list\"), items)) : ((LISP.isTrue((LISP.isTrue(LISP[\"pair?\"](result)) ? ((function(__8){return ((LISP.isTrue(__8) ? (__8) : (LISP[\"eq?\"](LISP.car(result), LISP.intern(\"list*\")))));})(LISP[\"eq?\"](LISP.car(result), LISP.intern(\"list\")))) : (LISP.nil))) ? (LISP.cons(LISP.car(result), LISP.append(items, LISP.cdr(result)))) : (LISP.cons(LISP.intern(\"list*\"), LISP.append(items, LISP.list(result))))))))));});\nLISP.macroexpand = (function(exp){return ((function(expanded){return ((LISP.isTrue(LISP[\"equal?\"](expanded, exp)) ? (exp) : (LISP.macroexpand(expanded))));})(LISP[\"macroexpand-1\"](exp)));});\nLISP[\"create-scope\"] = (function(parent$2dscope, params){return (LISP.vector(LISP[\"remove-if\"]((function() { var __2 = LISP.list(LISP.intern(\"&rest\"), LISP.intern(\"&body\")); return (function(x){return (LISP.member(x, __2));}); })(), params), LISP.nil, parent$2dscope));});\nLISP[\"scope-param\"] = (function(scope){return (LISP[\"vector-ref\"](scope, 0));});\nLISP[\"scope-outer\"] = (function(scope){return (LISP[\"vector-ref\"](scope, 2));});\nLISP[\"scope-add-var\"] = (function(scope, val){return ((function(x){return (LISP[\"vector-set!\"](scope, 1, LISP.cons(LISP.cons(x, val), LISP[\"vector-ref\"](scope, 1))), LISP[\"vector-set!\"](scope, 0, LISP.cons(x, LISP[\"vector-ref\"](scope, 0))), x);})(LISP.gensym()));});\nLISP[\"scope-get-var\"] = (function(scope){return (LISP[\"vector-ref\"](scope, 1));});\nLISP[\"scope-var?\"] = (function(scope, x){return ((LISP.isTrue(LISP[\"null?\"](scope)) ? (LISP.nil) : ((LISP.isTrue(LISP.member(x, LISP[\"scope-param\"](scope))) ? (LISP.t) : (LISP[\"scope-var?\"](LISP[\"scope-outer\"](scope), x))))));});\nLISP[\"local-var?\"] = (function(scope, sym){return ((LISP.isTrue(LISP[\"symbol?\"](sym)) ? (LISP[\"scope-var?\"](scope, LISP[\"get-receiver\"](sym))) : (LISP.nil)));});\nLISP[\"get-receiver\"] = (function(sym){return ((function(s){return ((function(it){return ((LISP.isTrue(it) ? (LISP.intern(LISP.substring(s, 0, it))) : (sym)));})(LISP[\"string-scan\"](s, \".\")));})(LISP[\"symbol->string\"](sym)));});\nLISP[\"register-macro\"](LISP.intern(\"record\"), (function(args, param){var body = LISP._getRestArgs(arguments, 2); return (LISP.list(LISP.intern(\"apply\"), LISP[\"list*\"](LISP.intern(\"lambda\"), param, body), args));}));\nLISP[\"register-macro\"](LISP.intern(\"record-case\"), (function(x){var clauses = LISP._getRestArgs(arguments, 1); return ((function(value){return (LISP.list(LISP.intern(\"let1\"), value, x, LISP[\"list*\"](LISP.intern(\"case\"), LISP.list(LISP.intern(\"car\"), value), LISP.map((function(clause){return ((LISP.isTrue(LISP[\"eq?\"](LISP.car(clause), LISP.t)) ? (clause) : ((function(key){return (LISP.list(LISP.list(key), LISP[\"list*\"](LISP.intern(\"record\"), LISP.list(LISP.intern(\"cdr\"), value), LISP.cdar(clause), LISP.cdr(clause))));})(LISP.caar(clause)))));}), clauses))));})(LISP.gensym()));}));\n(function(traverse$2dargs, confirm$2dvalid$2dparams, traverse$2dquoted$2dvalue){return (traverse$2dargs = (function(args, scope){return (LISP.map((function(x){return (LISP[\"traverse*\"](x, scope));}), args));}), confirm$2dvalid$2dparams = (function(params){return ((LISP.isTrue(params) ? ((LISP.isTrue(LISP[\"symbol?\"](LISP.car(params))) ? (confirm$2dvalid$2dparams(LISP.cdr(params))) : (LISP[\"compile-error\"](\"function parameter must be symbol, but\", LISP.car(params))))) : (LISP.nil)));}), traverse$2dquoted$2dvalue = (function(x){return ((LISP.isTrue(LISP[\"pair?\"](x)) ? (LISP.vector(LISP[\"make-keyword\"](\"FUNCALL\"), LISP.vector(LISP[\"make-keyword\"](\"REF\"), (LISP.isTrue(LISP[\"proper-list?\"](x)) ? (LISP.intern(\"list\")) : (LISP.intern(\"list*\")))), LISP.map(traverse$2dquoted$2dvalue, LISP[\"dotted->proper\"](x)))) : (LISP.vector(LISP[\"make-keyword\"](\"CONST\"), x))));}), LISP[\"traverse-list\"] = (function(s, scope){return ((function(__3){return ((function(__4){return ((LISP.isTrue(LISP[\"eq?\"](__4, LISP.intern(\"quote\"))) ? (LISP.apply((function(x){return ((LISP.isTrue(LISP[\"pair?\"](x)) ? (LISP.vector(LISP[\"make-keyword\"](\"REF\"), LISP[\"scope-add-var\"](scope, traverse$2dquoted$2dvalue(x)))) : (LISP.vector(LISP[\"make-keyword\"](\"CONST\"), x))));}), LISP.cdr(__3))) : ((LISP.isTrue(LISP[\"eq?\"](__4, LISP.intern(\"if\"))) ? (LISP.apply((function(p, thn){var els = LISP._getRestArgs(arguments, 2); return (LISP.vector(LISP[\"make-keyword\"](\"IF\"), LISP[\"traverse*\"](p, scope), LISP[\"traverse*\"](thn, scope), (LISP.isTrue(LISP[\"null?\"](els)) ? (LISP.nil) : (LISP[\"traverse*\"](LISP.car(els), scope)))));}), LISP.cdr(__3))) : ((LISP.isTrue(LISP[\"eq?\"](__4, LISP.intern(\"set!\"))) ? (LISP.apply((function(x, v){return (LISP.vector(LISP[\"make-keyword\"](\"SET!\"), LISP[\"traverse*\"](x, scope), LISP[\"traverse*\"](v, scope)));}), LISP.cdr(__3))) : ((LISP.isTrue(LISP[\"eq?\"](__4, LISP.intern(\"lambda\"))) ? (LISP.apply((function(params){var body = LISP._getRestArgs(arguments, 1); return ((function(){return (confirm$2dvalid$2dparams(params), (function(new$2dscope){return (LISP.vector(LISP[\"make-keyword\"](\"LAMBDA\"), new$2dscope, params, traverse$2dargs(body, new$2dscope)));})(LISP[\"create-scope\"](scope, params)));})());}), LISP.cdr(__3))) : ((LISP.isTrue(LISP[\"eq?\"](__4, LISP.intern(\"def\"))) ? (LISP.apply((function(name, value){return (LISP.vector(LISP[\"make-keyword\"](\"DEF\"), LISP[\"traverse*\"](name, scope), LISP[\"traverse*\"](value, scope)));}), LISP.cdr(__3))) : ((LISP.isTrue(LISP[\"eq?\"](__4, LISP.intern(\"new\"))) ? (LISP.apply((function(klass){var args = LISP._getRestArgs(arguments, 1); return (LISP.vector(LISP[\"make-keyword\"](\"NEW\"), klass, traverse$2dargs(args, LISP[\"new-scope\"])));}), LISP.cdr(__3))) : (LISP.vector(LISP[\"make-keyword\"](\"FUNCALL\"), LISP[\"traverse*\"](LISP.car(s), scope), traverse$2dargs(LISP.cdr(s), scope)))))))))))))));})(LISP.car(__3)));})(s));}));})(LISP.nil, LISP.nil, LISP.nil);\nLISP[\"traverse*\"] = (function(s, scope){return ((LISP.isTrue(LISP[\"pair?\"](s)) ? ((LISP.isTrue(LISP[\"local-var?\"](scope, LISP.car(s))) ? (LISP[\"traverse-list\"](s, scope)) : ((function(expanded){return ((LISP.isTrue(LISP[\"pair?\"](expanded)) ? (LISP[\"traverse-list\"](expanded, scope)) : (LISP[\"traverse*\"](expanded, scope))));})(LISP.macroexpand(s))))) : ((LISP.isTrue(LISP[\"symbol?\"](s)) ? (LISP.vector(LISP[\"make-keyword\"](\"REF\"), s)) : (LISP.vector(LISP[\"make-keyword\"](\"CONST\"), s))))));});\nLISP[\"expand-args\"] = (function(args, scope){return (LISP[\"string-join\"](LISP.map((function(x){return (LISP[\"compile*\"](x, scope));}), args), \", \"));});\nLISP[\"expand-body\"] = (function(body, scope){return ((LISP.isTrue(LISP[\"null?\"](body)) ? (\"LISP.nil\") : (LISP[\"expand-args\"](body, scope))));});\n(function(table){return (LISP[\"hash-table-put!\"](table, \"\\\\\", \"\\\\\\\\\"), LISP[\"hash-table-put!\"](table, \"\\t\", \"\\\\t\"), LISP[\"hash-table-put!\"](table, \"\\n\", \"\\\\n\"), LISP[\"hash-table-put!\"](table, \"\\\"\", \"\\\\\\\"\"), LISP[\"escape-char\"] = (function(c){return ((function(__5){return ((LISP.isTrue(__5) ? (__5) : (c)));})(LISP[\"hash-table-get\"](table, c)));}));})(LISP[\"make-hash-table\"]());\nLISP[\"escape-string\"] = (function(s){return (LISP[\"regexp-replace-all\"](/[\\\\\\t\\n\"]/, s, (function(m){return (LISP[\"escape-char\"](m()));})));});\nLISP[\"escape-sym-char\"] = (function(c){return (LISP[\"string-append\"](\"$\", LISP[\"integer->hex-string\"](LISP[\"char->integer\"](c), \"00\")));});\nLISP[\"integer->hex-string\"] = (function(x, padding){return ((function(s){return ((function(sl){return ((function(pl){return (LISP.substring(s, (sl - pl), sl));})(LISP[\"string-length\"](padding)));})(LISP[\"string-length\"](s)));})(LISP[\"string-append\"](padding, LISP[\"number->string\"](x, 16))));});\nLISP[\"escape-symbol\"] = (function(sym){return (LISP[\"regexp-replace-all\"](/[^0-9A-Za-z_.]/, LISP[\"symbol->string\"](sym), (function(m){return (LISP[\"escape-sym-char\"](LISP[\"string-ref\"](m(), 0)));})));});\nLISP[\"compile-symbol\"] = (function(sym, scope){return ((LISP.isTrue(LISP[\"local-var?\"](scope, sym)) ? (LISP[\"escape-symbol\"](sym)) : ((function(s){return ((LISP.isTrue(LISP.rxmatch(/^[0-9A-Za-z_.]*$/, s)) ? (LISP[\"string-append\"](\"LISP.\", s)) : (LISP[\"string-append\"](\"LISP[\\\"\", LISP[\"escape-string\"](s), \"\\\"]\"))));})(LISP[\"symbol->string\"](sym)))));});\nLISP[\"compile-keyword\"] = (function(keyword){return (LISP[\"string-append\"](\"LISP[\\\"make-keyword\\\"](\\\"\", LISP[\"escape-string\"](LISP[\"keyword->string\"](keyword)), \"\\\")\"));});\nLISP[\"compile-vector\"] = (function(vect, scope){return (LISP[\"string-append\"](\"[\", LISP[\"string-join\"](LISP.map((function(x){return (LISP[\"compile-quote\"](x, scope));}), LISP[\"vector->list\"](vect)), \", \"), \"]\"));});\nLISP[\"compile-regexp\"] = (function(regex){return (LISP[\"string-append\"](\"/\", LISP[\"regexp->string\"](regex), \"/\"));});\nLISP[\"compile-literal\"] = (function(s, scope){return ((LISP.isTrue(LISP[\"number?\"](s)) ? (LISP[\"number->string\"](s)) : ((LISP.isTrue(LISP[\"symbol?\"](s)) ? (LISP[\"compile-symbol\"](s, scope)) : ((LISP.isTrue(LISP[\"keyword?\"](s)) ? (LISP[\"compile-keyword\"](s)) : ((LISP.isTrue(LISP[\"string?\"](s)) ? (LISP[\"x->string\"](s, LISP.t)) : ((LISP.isTrue(LISP[\"vector?\"](s)) ? (LISP[\"compile-vector\"](s, scope)) : ((LISP.isTrue(LISP[\"regexp?\"](s)) ? (LISP[\"compile-regexp\"](s)) : ((LISP.isTrue(LISP[\"null?\"](s)) ? (\"LISP.nil\") : ((LISP.isTrue(LISP[\"eq?\"](s, LISP.t)) ? (\"LISP.t\") : (LISP.error(LISP[\"string-append\"](\"compile-literal: [\", s, \"]\")))))))))))))))))));});\nLISP[\"unary-op?\"] = (function() { var __6 = LISP.list(LISP.intern(\"+\"), LISP.intern(\"-\"), LISP.intern(\"!\"), LISP.intern(\"~\")); return (function(sym){return (LISP.member(sym, __6));}); })();\nLISP[\"compile-unary-op\"] = (function(fn, arg, scope){return (LISP[\"string-append\"](\"(\", LISP[\"symbol->string\"](fn), LISP[\"compile*\"](arg, scope), \")\"));});\nLISP[\"binop?\"] = (function() { var __7 = LISP.list(LISP.intern(\"+\"), LISP.intern(\"-\"), LISP.intern(\"*\"), LISP.intern(\"/\"), LISP.intern(\"%\")); return (function(sym){return (LISP.member(sym, __7));}); })();\nLISP[\"compile-binop\"] = (function(fn, args, scope){return (LISP[\"string-append\"](\"(\", LISP[\"string-join\"](LISP.map((function(x){return (LISP[\"compile*\"](x, scope));}), args), LISP[\"string-append\"](\" \", LISP[\"symbol->string\"](fn), \" \")), \")\"));});\nLISP[\"do-compile-funcall\"] = (function(fn, args, scope){return (LISP[\"string-append\"](LISP[\"compile*\"](fn, scope), \"(\", LISP[\"expand-args\"](args, scope), \")\"));});\nLISP[\"compile-funcall\"] = (function(fn, args, scope){return ((LISP.isTrue((LISP.isTrue(LISP[\"eq?\"](LISP[\"vector-ref\"](fn, 0), LISP[\"make-keyword\"](\"REF\"))) ? ((LISP.isTrue(LISP.not(LISP[\"local-var?\"](scope, LISP[\"vector-ref\"](fn, 1)))) ? (LISP.not(LISP[\"null?\"](args))) : (LISP.nil))) : (LISP.nil))) ? ((function(fnsym){return ((LISP.isTrue((LISP.isTrue(LISP[\"binop?\"](fnsym)) ? (LISP.not(LISP[\"null?\"](LISP.cdr(args)))) : (LISP.nil))) ? (LISP[\"compile-binop\"](fnsym, args, scope)) : ((LISP.isTrue((LISP.isTrue(LISP[\"unary-op?\"](fnsym)) ? (LISP[\"null?\"](LISP.cdr(args))) : (LISP.nil))) ? (LISP[\"compile-unary-op\"](fnsym, LISP.car(args), scope)) : (LISP[\"do-compile-funcall\"](fn, args, scope))))));})(LISP[\"vector-ref\"](fn, 1))) : (LISP[\"do-compile-funcall\"](fn, args, scope))));});\nLISP[\"compile-quote\"] = (function(x, scope){return ((LISP.isTrue(LISP[\"pair?\"](x)) ? (LISP[\"compile*\"](LISP.list(LISP.intern(\"cons\"), LISP.list(LISP.intern(\"quote\"), LISP.car(x)), LISP.list(LISP.intern(\"quote\"), LISP.cdr(x))), scope)) : ((LISP.isTrue(LISP[\"symbol?\"](x)) ? (LISP[\"string-append\"](\"LISP.intern(\\\"\", LISP[\"escape-string\"](LISP[\"symbol->string\"](x)), \"\\\")\")) : ((LISP.isTrue(LISP[\"keyword?\"](x)) ? (LISP[\"compile-keyword\"](x)) : (LISP[\"compile-literal\"](x, scope))))))));});\nLISP[\"compile-if\"] = (function(pred$2dnode, then$2dnode, else$2dnode, scope){return (LISP[\"string-append\"](\"(LISP.isTrue(\", LISP[\"compile*\"](pred$2dnode, scope), \") ? (\", LISP[\"compile*\"](then$2dnode, scope), \") : (\", (LISP.isTrue(else$2dnode) ? (LISP[\"compile*\"](else$2dnode, scope)) : (\"LISP.nil\")), \"))\"));});\nLISP[\"compile-set!\"] = (function(sym, val, scope){return (LISP[\"string-append\"](LISP[\"compile*\"](sym, scope), \" = \", LISP[\"compile*\"](val, scope)));});\nLISP[\"compile-lambda\"] = (function(params, bodies, base$2dscope, extended$2dscope){return ((LISP.isTrue((function(__8){return ((LISP.isTrue(__8) ? (__8) : (LISP[\"pair?\"](params))));})(LISP[\"null?\"](params))) ? (LISP.nil) : (LISP.error(\"function parameters must be a list\"))), (function(rest$2dpos){return ((function(proper$2dparams, rest){return (LISP[\"string-append\"](\"(function(\", LISP[\"string-join\"](LISP.map((function(x){return (LISP[\"escape-symbol\"](x));}), proper$2dparams), \", \"), \"){\", (LISP.isTrue(LISP[\"null?\"](rest)) ? (\"\") : (LISP[\"string-append\"](\"var \", LISP[\"escape-symbol\"](rest), \" = LISP._getRestArgs(arguments, \", LISP[\"number->string\"](LISP.length(proper$2dparams)), \"); \"))), \"return (\", LISP[\"expand-body\"](bodies, extended$2dscope), \");})\"));})((LISP.isTrue(rest$2dpos) ? (LISP.take(rest$2dpos, params)) : (params)), (LISP.isTrue(rest$2dpos) ? (LISP.elt((rest$2dpos + 1), params)) : (LISP.nil))));})(LISP[\"position-if\"]((function() { var __9 = LISP.list(LISP.intern(\"&rest\"), LISP.intern(\"&body\")); return (function(sym){return (LISP.member(sym, __9));}); })(), params)));});\nLISP[\"compile-def\"] = (function(name, value, scope){return (LISP[\"string-append\"](LISP[\"compile*\"](name, scope), \" = \", LISP[\"compile*\"](value, scope)));});\nLISP[\"compile-new\"] = (function(class$2dname, args, scope){return (LISP[\"string-append\"](\"new \", LISP[\"symbol->string\"](class$2dname), \"(\", LISP[\"expand-args\"](args, scope), \")\"));});\nLISP[\"compile-new-scope\"] = (function(scope, compiled$2dbody){return ((function(it){return ((LISP.isTrue(it) ? (LISP[\"string-append\"](\"(function() { var \", LISP[\"string-join\"](LISP.map((function(x){return (LISP[\"string-append\"](LISP[\"escape-symbol\"](LISP.car(x)), \" = \", LISP[\"compile*\"](LISP.cdr(x), scope)));}), LISP.reverse(it)), \", \"), \"; return \", compiled$2dbody, \"; })()\")) : (compiled$2dbody)));})(LISP[\"scope-get-var\"](scope)));});\nLISP[\"compile*\"] = (function(s, scope){return ((function(__10){return ((LISP.isTrue(LISP[\"eq?\"](__10, LISP[\"make-keyword\"](\"CONST\"))) ? (LISP[\"compile-quote\"](LISP[\"vector-ref\"](s, 1), scope)) : ((LISP.isTrue(LISP[\"eq?\"](__10, LISP[\"make-keyword\"](\"REF\"))) ? (LISP[\"compile-symbol\"](LISP[\"vector-ref\"](s, 1), scope)) : ((LISP.isTrue(LISP[\"eq?\"](__10, LISP[\"make-keyword\"](\"IF\"))) ? ((function(p, thn, els){return (LISP[\"compile-if\"](p, thn, els, scope));})(LISP[\"vector-ref\"](s, 1), LISP[\"vector-ref\"](s, 2), LISP[\"vector-ref\"](s, 3))) : ((LISP.isTrue(LISP[\"eq?\"](__10, LISP[\"make-keyword\"](\"FUNCALL\"))) ? (LISP[\"compile-funcall\"](LISP[\"vector-ref\"](s, 1), LISP[\"vector-ref\"](s, 2), scope)) : ((LISP.isTrue(LISP[\"eq?\"](__10, LISP[\"make-keyword\"](\"SET!\"))) ? (LISP[\"compile-set!\"](LISP[\"vector-ref\"](s, 1), LISP[\"vector-ref\"](s, 2), scope)) : ((LISP.isTrue(LISP[\"eq?\"](__10, LISP[\"make-keyword\"](\"LAMBDA\"))) ? ((function(extended$2dscope, params, body){return (LISP[\"compile-new-scope\"](extended$2dscope, LISP[\"compile-lambda\"](params, body, scope, extended$2dscope)));})(LISP[\"vector-ref\"](s, 1), LISP[\"vector-ref\"](s, 2), LISP[\"vector-ref\"](s, 3))) : ((LISP.isTrue(LISP[\"eq?\"](__10, LISP[\"make-keyword\"](\"DEF\"))) ? (LISP[\"compile-def\"](LISP[\"vector-ref\"](s, 1), LISP[\"vector-ref\"](s, 2), scope)) : ((LISP.isTrue(LISP[\"eq?\"](__10, LISP[\"make-keyword\"](\"NEW\"))) ? (LISP[\"compile-new\"](LISP[\"vector-ref\"](s, 1), LISP[\"vector-ref\"](s, 2), scope)) : (LISP[\"compile-error\"](\"Unknown AST node:\", s))))))))))))))))));})(LISP[\"vector-ref\"](s, 0)));});\nLISP[\"compile-error\"] = (function(){var args = LISP._getRestArgs(arguments, 0); return (LISP.error(args));});\nLISP.compile = (function(s){return ((function(top$2dscope){return ((function(tree){return (LISP[\"compile-new-scope\"](top$2dscope, LISP[\"compile*\"](tree, top$2dscope)));})(LISP[\"traverse*\"](s, top$2dscope)));})(LISP[\"create-scope\"](LISP.nil, LISP.nil)));});\n\n  return LISP\n}, (LISP) => {\n  // Using eval JS function prevent uglify to mangle local variable names,\n  // so put such code here.\n  LISP.eval = (exp) => eval(LISP.compile(exp))\n})\n"],"sourceRoot":"/source/"}