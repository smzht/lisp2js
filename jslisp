#!/usr/bin/env node
//-*- mode:js -*-

(function() {
  'use strict';

  var LISP;

  // Run codes.
  var runCodes = function(codes, compile) {
    var reader = new LISP.Reader(codes);
    var result;
    for (;;) {
      var s = reader.read();
      if (!s)
        return result;

      if (compile) {
        result = LISP.compile(s);
        LISP.print(result + ';\n');
      } else {
        result = LISP.eval(s);
      }
    }
  };

  // Read-Eval-Print loop.
  var repl = function() {
    process.stdin.resume();
    process.stdin.setEncoding('utf8');

    var tty = require('tty');
    var isatty = tty.isatty(0);  // Whether the stdin is a tty.
    var prompt1 = '> ';
    var prompt2 = '| ';
    var inputs = [];

    if (isatty)
      process.stdout.write(prompt1);
    process.stdin.on('data', function (chunk) {
      inputs.push(chunk);
      try {
        var result = runCodes(inputs.join(''), compileOnly);
        // Otherwise input should be consumed.
        inputs = [];
        if (isatty) {
          console.log(LISP.makeString(result, 10));
          process.stdout.write(prompt1);
        }
      } catch (e) {
        if (e instanceof LISP.NoCloseParenException) {
          // In REPL, if NoCloseParenException occurs,
          // a user keep typing so inputs should be kept.
          if (isatty) {
            process.stdout.write(prompt2);
          }
        } else {
          console.error(e);
          if (!isatty)
            process.exit(1);
          inputs = [];
          process.stdout.write(prompt1);
        }
      }
    });
    process.stdin.on('end', function () {
      if (inputs.length > 0) {
        console.error('Input not terminated: [' + inputs + ']');
        process.exit(1);
        return;
      }
      process.exit(0);
    });
  };

  // Run script.
  var fs = require('fs');
  var runArgv = function(index, onFinish) {
    if (index >= process.argv.length) {
      return onFinish(null);
    }
    var fileName = process.argv[index];
    fs.readFile(fileName, 'utf-8', function(error, text) {
      if (error) {
        return onFinish('File open error [' + fileName + ']: ' + error);
      }

      runCodes(text, compileOnly);
      runArgv(index + 1, onFinish);
    });
  };


  // Main.
  var translator = "./lisp2js.js";
  var index = 2;
  var compileOnly = false;
  for (; index < process.argv.length; ++index) {
    var option = process.argv[index];
    if (option == '-c') {
      compileOnly = true;
      continue;
    }
    if (option == '-t') {
      translator = process.argv[++index];
      continue;
    }
    break;
  }

  LISP = require(translator);

  if (index >= process.argv.length) {  // No input file name: read from stdin.
    return repl();
  } else {  // Process command line argument files.
    runArgv(index, function(error) {
      if (error !== null) {
        console.error(error);
        return process.exit(1);
      }
      process.exit(0);
    });
  }
})();
