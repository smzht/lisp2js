#!/usr/bin/env node

(function() {
  require("./runtime/lisp.js");

  // Read all input from stdin, and fire callback.
  var readAllFromStdin = function(callback) {
    process.stdin.resume();
    process.stdin.setEncoding('utf8');

    var all = '';
    process.stdin.on('data', function (chunk) {
      all += chunk;
    });
    process.stdin.on('end', function () {
      callback(all);
    });
  };

  // Run codes.
  var runCodes = function(codes, compile) {
    var reader = new LISP.Reader(codes);
    var s;
    for (;;) {
      s = reader.read();
      if (!s)
        break;

      if (compile) {
        var compiled = LISP.compile(s);
        LISP.print(compiled + ';');
      } else {
        LISP.eval(s);
      }
    }
    return s === undefined;
  };

  var translator = "./lisp2js.js";
  var index = 2;
  var compileOnly = false;
  for (; index < process.argv.length; ++index) {
    var option = process.argv[index];
    if (option == '-c') {
      compileOnly = true;
      continue;
    }
    if (option == '-t') {
      translator = process.argv[++index];
      continue;
    }
    break;
  }

  require(translator);

  if (index >= process.argv.length) {
    readAllFromStdin(function(text) {
      process.exit(runCodes(text, compileOnly) ? 0 : 1);
    });
  } else {
    var fs = require('fs');
    var loop = function(index) {
      if (index >= process.argv.length) {
        process.exit(0);
        return;
      }
      var fileName = process.argv[index];
      if (fileName === '-c') {
        compileOnly = true;
        return loop(index + 1);
      }
      fs.readFile(fileName, 'utf-8', function(error, text) {
        if (error) {
          console.error('File open error [' + fileName + ']: ' + error);
          process.exit(1);
        }

        if (!runCodes(text, compileOnly))
          process.exit(1);
        loop(index + 1);
      });
    };
    loop(index);
  }
})();
