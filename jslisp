#!/usr/bin/env node
//-*- mode:js -*-

(() => {
  'use strict'

  let LISP

  // Run codes.
  const runCodes = (codes, compile) => {
    const stream = new LISP.StrStream(codes)
    let result
    for (;;) {
      const s = LISP.read(stream)
      if (s == null)
        return result

      if (compile) {
        result = LISP.compile(s)
        LISP.print(result + ';\n')
      } else {
        result = LISP.eval(s)
      }
    }
  }

  // Read-Eval-Print loop.
  const repl = () => {
    process.stdin.resume()
    process.stdin.setEncoding('utf8')

    const tty = require('tty')
    const isatty = tty.isatty(0)  // Whether the stdin is a tty.
    const prompt = '> '
    const inputs = []

    if (isatty)
      process.stdout.write(prompt)
    process.stdin.on('data', (chunk) => {
      inputs.push(chunk)
      try {
        const code = inputs.join('')
        if (code.match(/^\s*$/)) {
          inputs.length = 0
        } else {
          const result = runCodes(code, compileOnly)
          // Otherwise input should be consumed.
          inputs.length = 0
          if (isatty)
            console.log(LISP['x->string'](result, 10))
        }
        if (isatty)
          process.stdout.write(prompt)
      } catch (e) {
        if (e instanceof LISP.NoCloseParenException) {
          // In REPL, if NoCloseParenException occurs,
          // a user keep typing so inputs should be kept.
        } else {
          console.error('Error: ' + e.toString())
          if (!isatty)
            process.exit(1)
          inputs.length = 0
          process.stdout.write(prompt)
        }
      }
    })
    process.stdin.on('end', () => {
      if (inputs.length > 0) {
        console.error('Input not terminated: [' + inputs + ']')
        process.exit(1)
        return
      }
      process.exit(0)
    })
  }

  // Run script.
  const fs = require('fs')

  // Main.
  let translator = null
  let index = 2
  let compileOnly = false
  for (; index < process.argv.length; ++index) {
    const option = process.argv[index]
    if (option == '-c') {
      compileOnly = true
      continue
    }
    if (option == '-t') {
      translator = process.argv[++index]
      continue
    }
    break
  }

  if (translator == null) {
    try {
      if (fs.statSync(__dirname + '/lisp2js.js').isFile())
        translator = './lisp2js'
    } catch (e) {
      translator = './lisp2js.min'
    }
  }
  LISP = require(translator)

  if (index >= process.argv.length) {  // No input file name: read from stdin.
    return repl()
  }

  // Process command line argument as a script file.
  try {
    LISP['*argv*'] = LISP['vector->list'](process.argv.slice(index + 1))
    let status = 0
    if (compileOnly) {
      const text = fs.readFileSync(process.argv[index], 'utf-8')
      const matchShebang = text.match(/^#!(.*)\n/)
      if (matchShebang)
        text = text.slice(matchShebang[0].length)
      runCodes(text, compileOnly)
    } else {
      LISP.load(process.argv[index])
      if ('main' in LISP)
        status = LISP.main(LISP.cons(process.argv[index], LISP['*argv*']))
    }
    if (status)
      process.exit(status)
  } catch (e) {
    process.stderr.write(e.toString() + '\n')
    process.exit(1)
  }
})()
